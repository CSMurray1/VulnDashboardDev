<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Vulnerability Dashboard</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90' text-anchor='middle' x='50'%3E%F0%9F%AA%B2%3C/text%3E%3C/svg%3E">
<!-- ===== Global Styles ===== -->
<style>
:root {
  --bg-light: #f8f9fa;
  --text-light: #212529;
  --panel-light: #ffffff;
  --border-light: #dee2e6;
  --link-light: #0d6efd;
  --bg-dark: #121212;
  --text-dark: #e9ecef;
  --panel-dark: #1e1e1e;
  --border-dark: #343a40;
  --link-dark: #8ab4f8;
  --input-bg-dark: #2d2d2d;
  --input-text-dark: #e9ecef;
  --heat-bar: #0d6efd;
}
/* Base */
body {
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  margin: 0;
  background: var(--bg-light);
  color: var(--text-light);
  line-height: 1.6;
}
body.dark {
  background: var(--bg-dark);
  color: var(--text-dark);
}
a {
  color: var(--link-light);
  text-decoration: none;
}
body.dark a { color: var(--link-dark); }
a:hover { text-decoration: underline; }
/* Top nav tabs */
nav {
  display: flex;
  justify-content: center;
  background: #444;
  color: white;
}
nav button {
  flex: 1;
  padding: 14px;
  font-size: 16px;
  color: white;
  background: #444;
  border: none;
  cursor: pointer;
  outline: none;
  transition: background 0.3s;
}
nav button.active { background: #0074d9; }
nav button:hover { background: #555; }
/* Tabs container limits show/hide scope */
.tabs > section { display: none; padding: 20px; }
.tabs > section.active { display: block; }
/* Mode Toggle Button (floating) */
.mode {
  position: fixed;
  top: 14px;
  right: 14px;
  padding: 8px 16px;
  font-size: 14px;
  color: #333;
  background: #ddd;
  border: 1px solid #ccc;
  border-radius: 5px;
  cursor: pointer;
  z-index: 1000;
}
body.dark .mode {
  background: #444;
  color: #f4f4f9;
  border-color: #666;
}
/* Dashboard 1 (CVE) Header */
header.cve-header {
  padding: 20px;
  background: inherit;
  border-bottom: 1px solid var(--border-light);
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
  position: sticky;
  top: 0;
  z-index: 10;
}
body.dark header.cve-header { border-color: var(--border-dark); }
header.cve-header h1 {
  margin: 0;
  font-size: 22px;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 12px;
}
header.cve-header h1::before {
  content: "";
  display: block;
  width: 36px;
  height: 36px;
  background: url("data:image/svg+xml,<svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 100 100&quot;><text y=&quot;.9em&quot; font-size=&quot;90&quot; text-anchor=&quot;middle&quot; x=&quot;50&quot;>ü™≤</text></svg>") center / contain no-repeat;
}
#cve {
  flex: 1;
  min-width: 300px;
  padding: 12px 16px;
  font-size: 16px;
  border: 1px solid var(--border-light);
  border-radius: 8px;
  background: var(--panel-light);
}
body.dark #cve {
  background: var(--input-bg-dark);
  border-color: var(--border-dark);
  color: var(--input-text-dark);
}
.btn {
  padding: 10px 18px;
  border: 1px solid var(--border-light);
  background: var(--panel-light);
  color: var(--text-light);
  border-radius: 8px;
  cursor: pointer;
  font-weight: 500;
}
body.dark .btn {
  background: var(--input-bg-dark);
  border-color: var(--border-dark);
  color: var(--text-dark);
}
/* Dashboard 1 Layout */
main.cve-main {
  display: grid;
  grid-template-columns: 1fr 1fr 350px;
  grid-template-areas:
    "details details watch"
    "sources relevant vulncheck";
}
@media (max-width:1400px) {
  main.cve-main {
    grid-template-columns: 1fr 1fr;
    grid-template-areas:
      "details details"
      "watch watch"
      "vulncheck vulncheck"
      "sources relevant";
  }
}
@media (max-width:1000px) {
  main.cve-main {
    grid-template-columns: 1fr;
    grid-template-areas:
      "details"
      "watch"
      "vulncheck"
      "sources"
      "relevant";
  }
}
#cveDetails { grid-area: details; }
#exploitationWatch {
  display: flex;
  flex-direction: column;
  height: 100%; /* Fill its grid cell */
  min-height: 120px; /* Prevent collapsing */
  max-height: none; /* Remove old fixed cap */
}
#exploitationWatch > header {
  flex: 0 0 auto;             /* don't grow/shrink */
}
#watchContent:empty {
  min-height: 120px; /* fallback */
  max-height: 200px; /* roughly 5 items */
}
#vulncheckMonitor { grid-area: vulncheck; }
#notableSources { grid-area: sources; }
#relevantSearches { grid-area: relevant; }

/* Panels */
.panel {
  background: var(--panel-light);
  border: 1px solid var(--border-light);
  border-radius: 12px;
  overflow: hidden;
}
body.dark .panel {
  background: var(--panel-dark);
  border-color: var(--border-dark);
}
.panel > header {
  padding: 14px 18px;
  border-bottom: 1px solid var(--border-light);
  background: rgba(0,0,0,0.03);
}
body.dark .panel > header {
  border-color: var(--border-dark);
  background: rgba(255,255,255,0.03);
}
.panel > header h2 {
  margin: 0;
  font-size: 16px;
  font-weight: 600;
}
.content { padding: 16px 18px; }
.item {
  padding: 12px 0;
  border-bottom: 1px dashed var(--border-light);
}
body.dark .item { border-color: #444; }
.item:last-child { border: none; }
.title { font-weight: 600; margin-bottom: 6px; }
.meta { font-size: 14px; opacity: .9; }
/* Chips & badges */
.chip {
  display: inline-block;
  padding: 4px 10px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 700;
  color: white;
  margin-left: 8px;
}
.low{background:#2d7f3a;}
.medium{background:#b57f00;}
.high{background:#cc4a00;}
.critical{background:#a60000;}
.badge {
  display: inline-block;
  padding: 5px 10px;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;
}
.yes{background:#d4edda;color:#155724;}
.no{background:#f8d7da;color:#721c24;}
body.dark .yes{background:#1e3f2a;color:#a7f3c0;}
body.dark .no{background:#4a1e20;color:#f5b5bb;}
/* Link row + Copy */
.link-row {
  margin:6px 0;
  display:flex;
  align-items:center;
  gap:8px;
}
.link-row a { word-break:break-all; }
.copy-link {
  font-size:12px;
  padding:4px 8px;
  border:1px solid var(--border-light);
  background: var(--panel-light);
  border-radius:4px;
  cursor:pointer;
}
body.dark .copy-link {
  border-color: var(--border-dark);
  background: var(--input-bg-dark);
  color: var(--text-dark);
}
/* EPSS/SSVC layout */
.metrics-row {
  display:flex;
  gap:16px;
  flex-wrap:wrap;
  align-items:flex-start;
  margin-top:12px;
}
.metrics-col { flex: 1 1 360px; min-width: 280px; }
.metrics-box {
  padding: 12px;
  background: rgba(13,110,253,0.1);
  border-radius: 8px;
  margin-top: 4px;
  font-size: 14px;
}
body.dark .metrics-box { background: rgba(13,110,253,0.2); }
.metrics-box .title {
  font-weight: 600;
  margin-bottom: 8px;
  color: #0d6efd;
}
.metrics-box table {
  width: 100%;
  border-collapse: collapse;
  background: transparent;
  color: inherit;
}
.metrics-box th, .metrics-box td {
  padding: 8px;
  text-align: left;
  border-bottom: 1px solid rgba(13,110,253,0.3);
}
.metrics-box th {
  font-weight: 600;
  color: #0d6efd;
}
/* Toast + Loading */
#toast {
  position:fixed;
  bottom:30px;
  left:50%;
  transform:translateX(-50%);
  background:#333;
  color:#fff;
  padding:12px 24px;
  border-radius:8px;
  display:none;
  z-index:1000;
}
#loading {
  position:fixed;
  top:0;
  left:0;
  width:100%;
  height:100%;
  background: rgba(0,0,0,0.7);
  color:#fff;
  font-size:24px;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:1200;
}
/* Modal (Attack Visualizer.) */
#attackModal {
  display:none;
  position:fixed;
  top:0;
  left:0;
  width:100%;
  height:100%;
  background: var(--bg-light);
  z-index:1100;
}
body.dark #attackModal { background: var(--bg-dark); }
#attackGraph { width:100%; height: calc(100% - 60px); }
#closeModal {
  position:absolute;
  top:10px;
  right:10px;
  z-index:1110;
}
.settings-content {
  background: var(--panel-light);
  padding:30px;
  border-radius:12px;
  width:90%;
  max-width:520px;
  color:inherit;
}
body.dark .settings-content { background: var(--panel-dark); }
.settings-content input, .settings-content textarea {
  width:100%;
  padding:10px;
  margin-top:6px;
  border-radius:6px;
  border:1px solid var(--border-light);
  background: var(--panel-light);
  color: var(--text-light);
}
body.dark .settings-content input, body.dark .settings-content textarea {
  background: var(--input-bg-dark);
  border-color: var(--border-dark);
  color: var(--input-text-dark);
}
.settings-content label {
  display:block;
  margin-bottom:16px;
  font-weight:600;
}
/* Prevalence modal */
#prevalenceModal {
  display:none;
  position:fixed;
  top:0;
  left:0;
  width:100%;
  height:100%;
  background: rgba(0,0,0,0.65);
  z-index:1250;
  align-items:center;
  justify-content:center;
  padding:20px;
}
.prev-content {
  background: var(--panel-light);
  color:inherit;
  border:1px solid var(--border-light);
  border-radius:12px;
  max-width:920px;
  width:95%;
  max-height:85vh;
  overflow:auto;
  padding:20px 24px;
}
body.dark .prev-content {
  background: var(--panel-dark);
  border-color: var(--border-dark);
}
.prev-header {
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:12px;
}
/* Dark mode fix for AI Analysis modal */
body.dark #analysisModal > div {
  background: var(--panel-dark);
  color: var(--text-dark);
  border-color: var(--border-dark);
}
body.dark #analysisBody {
  background: var(--input-bg-dark);
  color: var(--input-text-dark);
  border-color: var(--border-dark);
}
body.dark #analysisStatus {
  color: var(--text-dark);
}
/* Dark mode fix for AI Analysis modal outer container */
body.dark #analysisModal > div {
  background: var(--panel-dark);
  color: var(--text-dark);
  border-color: var(--border-dark);
}
/* Ensure headings and buttons inside modal adapt */
body.dark #analysisModal h3 {
  color: var(--text-dark);
}
body.dark #analysisModal .btn {
  background: var(--input-bg-dark);
  color: var(--text-dark);
  border-color: var(--border-dark);
}
/* Analysis body box (where text streams) */
body.dark #analysisBody {
  background: var(--input-bg-dark);
  color: var(--input-text-dark);
  border-color: var(--border-dark);
}
/* Dashboard 2 (Feeds) */
.feeds-header { text-align:center; }
.feed-container { display:flex; flex-wrap:wrap; gap:1rem; justify-content:center; }
.feed {
  background-color: white;
  border: 1px solid #ddd;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  padding: 15px;
  width: 300px;
}
body.dark .feed {
  background-color: #2e2e50;
  border-color: #444;
  box-shadow: none;
}
.feed h2 { font-size: 18px; color: inherit; margin-bottom: 5px; }
.feed ul { list-style:none; padding:0; margin:0; }
.feed ul li { margin-bottom:10px; }
.feed ul li a { color: #0074d9; text-decoration: none; }
body.dark .feed ul li a { color: #5caeff; }
/* Watcher notify panel */
#watcherNotify {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 1400;
  display: none;
  max-width: 500px; /* Wider for content */
  width: 90%; /* Responsive */
  padding: 16px;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  background: var(--panel-light);
  color: var(--text-light);
  border: 1px solid var(--border-light);
}
body.dark #watcherNotify {
  background: var(--panel-dark);
  color: var(--text-dark);
  border: 1px solid var(--border-dark);
}
body.dark #watcherList::placeholder { color: #bbb; }
/* Force dark mode for AI Analysis modal outer container */
body.dark #analysisModal > div {
  background: var(--panel-dark) !important;
  color: var(--text-dark) !important;
  border-color: var(--border-dark) !important;
}
/* Exploitation Watcher Scrollbar */
#watchContent {
  flex: 1 1 0%;             /* or flex: 1 1 0px */
  min-height: 0;
  overflow-y: auto;
  display: flex;            /* optional but often helps nested content */
  flex-direction: column;
  padding: 12px;
  background: #fafafa;
}
body.dark #watchContent {
  background: #1e1e1e;
}
#watchContent::-webkit-scrollbar {
  width: 8px;
}
#watchContent::-webkit-scrollbar-thumb {
  background: #aaa;
  border-radius: 4px;
}
#watchContent::-webkit-scrollbar-thumb {
  background: #aaa;
  border-radius: 4px;
}
body.dark #watchContent::-webkit-scrollbar-thumb {
  background: #666;
}
body.dark #watchContent::-webkit-scrollbar-thumb {
  background: #666;
}
body.dark #watchContent {
  background: #1e1e1e;
}
</style>
</head>
<body class="light">
<!-- CVE Watcher sound (hidden) -->
<audio id="watcherSound" preload="auto" src="https://actions.google.com/sounds/v1/alarms/httpshort.ogg"></audio>
<button class="mode" onclick="toggleMode()">Dark Mode</button>
<nav>
  <button onclick="switchTab(0)" class="active">CVE Dashboard</button>
  <button onclick="switchTab(1)">CyberWatch Dashboard</button>
</nav>
<div class="tabs">
  <section id="tab1" class="active">
    <header class="cve-header">
      <h1>Vulnerability Analysis Dashboard</h1>
      <input id="cve" type="text" placeholder="Enter CVE (e.g., CVE-2021-44228) or Vendor/Product" />
      <button id="go" class="btn">Run</button>
      <button id="clearCve" class="btn">Clear</button>
      <button id="aiAnalysis" class="btn">AI Analysis</button>
    </header>
    <main class="cve-main">
      <!-- panels unchanged -->
      <div id="cveDetails" class="panel"><header><h2>CVE Details &amp; Exploitation Signals</h2></header><div class="content" id="cveContent"><div class="meta">Enter a CVE or Vendor/Product and click Run.</div></div></div>
      <div id="exploitationWatch" class="panel"><header><h2>CVE &amp; Exploitation Watcher</h2></header><div class="content" id="watchContent"><div class="meta">Loading feeds‚Ä¶</div></div></div>
      <div id="vulncheckMonitor" class="panel"><header><h2>Recent VulnCheck KEV (last 10 days)</h2></header><div class="content" id="vulncheckContent"><div class="meta">Loading...</div></div></div>
      <div id="notableSources" class="panel"><header><h2>Notable Sources &amp; References</h2></header><div class="content" id="sourcesContent"><div class="meta">Will appear after running a CVE.</div></div></div>
      <div id="relevantSearches" class="panel"><header><h2>Relevant Searches &amp; Monitoring</h2></header><div class="content" id="searchLinks"><div class="meta">Enter a term above and click Run to populate links.</div></div></div>
    </main>
    <div id="toast"></div>
    <div id="loading">Loading data...</div>
    <!-- Attack Visualizer Modal -->
    <div id="attackModal"><div class="prev-content"><div id="attackGraph"></div><button id="closeModal" class="btn">Close Visualizer</button></div></div>
    <!-- Prevalence Modal -->
    <div id="prevalenceModal"><div class="prev-content"><div class="prev-header"><h3 id="prevTitle">Prevalence</h3><button class="btn" onclick="document.getElementById('prevalenceModal').style.display='none'">Close</button></div><div id="prevBody"></div></div></div>
    <!-- AI Analysis Results Modal -->
    <div id="analysisModal" role="dialog" aria-modal="true" aria-labelledby="analysisTitle" style="display:none; position:fixed; inset:0; background: rgba(0,0,0,0.6); z-index:1450; align-items:center; justify-content:center;">
      <div style="background: var(--panel-light); color: inherit; border:1px solid var(--border-light); border-radius:12px; width:92%; max-width:860px; max-height:85vh; overflow:auto; padding:18px;">
        <h3 id="analysisTitle" style="margin-top:0">AI Analysis</h3>
        <div id="analysisStatus" class="meta" style="margin-bottom:12px">Preparing analysis‚Ä¶</div>
        <div id="analysisBody" style="white-space:pre-wrap; font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Arial; border:1px solid var(--border-light); border-radius:8px; padding:12px; min-height:160px;"></div>
        <div style="display:flex; gap:12px; margin-top:12px; flex-wrap:wrap;">
          <button id="analysisCopy" class="btn">Copy</button>
          <button id="analysisSave" class="btn">Download .md</button>
          <button id="analysisCancel" class="btn">Cancel</button>
          <button id="analysisClose" class="btn">Close</button>
        </div>
      </div>
    </div>
  </section>
  <section id="tab2">
    <div class="feeds-header">
      <h1>Live Cybersecurity Exploits Monitor</h1>
      <div style="margin: 12px 0;"><button class="btn" onclick="displayFeeds()">Refresh Feeds</button></div>
    </div>
    <div id="feed-container" class="feed-container"></div>
  </section>
</div>
<script>
/* ---------- Origins & Endpoints ---------- */
const IS_FILE_ORIGIN = location.protocol === 'file:';
/* ---------- UI Utilities ---------- */
function toast(msg) {
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.style.display = "block";
  setTimeout(() => t.style.display = "none", 3000);
}
function toggleMode() {
  document.body.classList.toggle('dark');
  const modeBtn = document.querySelector(".mode");
  if (modeBtn) modeBtn.textContent = document.body.classList.contains("dark") ? "Light Mode" : "Dark Mode";
  const themeBtn = document.getElementById("theme");
  if (themeBtn) themeBtn.textContent = document.body.classList.contains("dark") ? "Light Mode" : "Dark Mode";
  localStorage.setItem("theme", document.body.classList.contains("dark") ? "dark" : "light");
}
function initTheme() {
  const saved = localStorage.getItem("theme");
  if (saved === "dark") {
    document.body.classList.add("dark");
    const modeBtn = document.querySelector(".mode"); if (modeBtn) modeBtn.textContent = "Light Mode";
    const themeBtn = document.getElementById("theme"); if (themeBtn) themeBtn.textContent = "Light Mode";
  }
  document.getElementById("theme")?.addEventListener("click", toggleMode);
}

/* ---------- Utility Helpers ---------- */
function severityFromScore(score) {
  return score < 4 ? 'Low' : score < 7 ? 'Medium' : score < 9 ? 'High' : 'Critical';
}

function classFromScore(score) {
  return score < 4 ? 'low' : score < 7 ? 'medium' : score < 9 ? 'high' : 'critical';
}

function capFirst(str) {
  return (str || '').charAt(0).toUpperCase() + (str || '').slice(1);
}

function normalizeSsvcValue(val) {
  return (val || 'N/A').toLowerCase().replace(/^(active|none|proof-of-concept|sporadic)$/i, m => m.toLowerCase());
}

function linkRow(url, label) {
  const safeLabel = label || url;
  return `<a href="${url}" target="_blank" rel="noopener noreferrer">${safeLabel}</a>`;
}

// Helper to build the CISA KEV catalog URL for a CVE
function cisaKevUrl(cve) {
  return `https://www.cisa.gov/known-exploited-vulnerabilities-catalog?field_cve=${encodeURIComponent(cve)}`;
  
// Initialize the sound toggle state
const soundToggle = document.getElementById('watcherSoundToggle');
 if (soundToggle) {
   const enabled = localStorage.getItem('watcherSoundEnabled') !== 'false';
   soundToggle.checked = enabled;


  soundToggle.addEventListener('change', () => {
    localStorage.setItem('watcherSoundEnabled', soundToggle.checked ? 'true' : 'false');
    toast && toast(soundToggle.checked ? 'Sound notifications enabled' : 'Sound notifications disabled');
  });
}
  
/* ---------- CWE Builder ---------- */
function buildCweHtml(cveJson, nvdJson) {
  const rows = [];
  const cna = cveJson?.containers?.cna;
  const cnaAssigner = cna?.providerMetadata?.shortName || 'CNA';
  const cnaPts = Array.isArray(cna?.problemTypes) ? cna.problemTypes : [];
  cnaPts.forEach(pt => { (pt.descriptions || []).forEach(d => { rows.push({ source: cnaAssigner, cweId: d?.cweId || d?.id || null, description: d?.description || d?.value || '' }); }); });
  const adps = Array.isArray(cveJson?.containers?.adp) ? cveJson.containers.adp : [];
  adps.forEach(p => {
    const src = p?.providerMetadata?.shortName || 'ADP';
    const pts = Array.isArray(p?.problemTypes) ? p.problemTypes : [];
    pts.forEach(pt => { (pt.descriptions || []).forEach(d => { rows.push({ source: src, cweId: d?.cweId || d?.id || null, description: d?.description || d?.value || '' }); }); });
  });
  const nvdCve = nvdJson?.vulnerabilities?.[0]?.cve;
  const weaknesses = Array.isArray(nvdCve?.weaknesses) ? nvdCve.weaknesses : [];
  weaknesses.forEach(w => {
    const src = 'NVD - NIST';
    const descs = w?.description || w?.descriptions || [];
    (descs || []).forEach(d => {
      const text = d?.value || d?.description || '';
      const idMatch = text?.match(/\bCWE-\d{1,5}\b/);
      rows.push({ source: src, cweId: idMatch ? idMatch[0] : (w?.type || null), description: text });
    });
  });
  const seen = new Set();
  const uniq = rows.filter(r => { const key = `${r.source}|${r.cweId || ''}|${r.description || ''}`; if (seen.has(key)) return false; seen.add(key); return true; });
  if (!uniq.length) return '<div class="meta">No CWE data available.</div>';
  return uniq.map(r => `<div class="item"><div class="title">CWE ID: ${r.cweId || 'Unknown'} - ${r.description || 'No Description'}</div><div class="meta">Assigner: ${r.source}</div></div>`).join('');
}
/* ---------- Prompt Builder ---------- */
let __lastAnalysisContext = null;
let __lastVulncheckRecent = [];
function buildAnalysisPrompt(ctx) {
  if (!ctx) {
    return [
      'You are a security analyst. Provide a concise, technically rigorous vulnerability analysis.',
      '',
      'Deliverables:',
      '1) Executive summary.',
      '2) Root cause & vulnerable components/conditions.',
      '3) Exploitability (pre-/post-auth, network exposure).',
      '4) Impact & blast radius; relevant MITRE ATT&CK techniques.',
      '5) Detection ideas (logs, artifacts, controls).',
      '6) Mitigation/patch priorities & safe workarounds.',
      '7) Risk scoring rationale (tie to KEV/EPSS/CVSS).',
      '',
      'State unknowns explicitly; do not guess.'
    ].join('\n');
  }
  const { input, isCVE, cnaName, description, kevYes, ransomwareTag, epss, cvss = [], cwes = [], referencesGrouped = [] } = ctx;
  const cvssLines = cvss.length ? cvss.map(m => `- CVSS v${m.version}: ${m.score} (${m.source})${m.vector ? ` | ${m.vector}` : ''}`).join('\n') : '- CVSS: (none)';
  const cweLines = cwes.length ? cwes.map(c => `- ${c.id || 'Unknown'} ‚Äî ${c.desc || 'No description'} (Assigner: ${c.assigner || 'Unknown'})`).join('\n') : '- CWE: (none)';
  const refLines = referencesGrouped.length ? referencesGrouped.map(g => { const links = (g.links || []).slice(0, 4).map(r => ` ‚Ä¢ ${r.name || r.url}: ${r.url}`).join('\n'); return `- ${g.host}\n${links}`; }).join('\n') : '- References: (none)';
  const epssLine = (epss && typeof epss.score === 'number') ? `EPSS: ${epss.score.toFixed(4)} (~${(epss.score * 100).toFixed(2)}% 30-day), Percentile: ${(epss.percentile * 100).toFixed(1)}%` : `EPSS: (no data)`;
  const kevLine = kevYes
    ? `CISA KEV: ${cisaKevUrl(input)} (Ransomware: ${String(ransomwareTag || 'Unknown')})`
    : `CISA KEV: No`;
  return [
    `Provide a concise, technically rigorous analysis for ${isCVE ? 'CVE' : 'product'}: ${input}.`,
    ``,
    `Context from dashboard:`,
    `CNA: ${cnaName || 'Unknown'}`,
    `Description: ${description || 'No description found'}`,
    `${kevLine}`,
    `${epssLine}`,
    ``,
    `CVSS metrics:`,
    `${cvssLines}`,
    ``,
    `CWE(s):`,
    `${cweLines}`,
    ``,
    `References (top sources):`,
    `${refLines}`,
    ``,
    `Deliverables:`,
    `1) Executive summary.`,
    `2) Root cause & vulnerable components/conditions.`,
    `3) Exploitability (pre-/post-auth, network exposure).`,
    `4) Impact & blast radius; key ATT&CK techniques.`,
    `5) Detection ideas (logs, artifacts, controls).`,
    `6) Mitigation/patch priorities & safe workarounds.`,
    `7) Risk scoring rationale (tie to KEV/EPSS/CVSS).`,
    ``,
    `State unknowns explicitly; do not guess.`
  ].join('\n');
}
/* ---------- Static Analysis ---------- */

function generateStaticAnalysis(ctx) {
  const { input, isCVE, cnaName, description, kevYes, ransomwareTag, epss, cvss = [], cwes = [] } = ctx || {};
  const cvssText = cvss.length
    ? cvss.map(m => `- **CVSS v${m.version}**: ${m.score} _(source: ${m.source}; vector: ${m.vector || 'N/A'})_`).join('\n')
    : '- **CVSS**: No metrics available';
  const cweText = cwes.length
    ? cwes.map(c => `- **${c.id || 'Unknown'}** ‚Äî ${c.desc || 'No description'} _(Assigner: ${c.assigner || 'Unknown'})_`).join('\n')
    : '- **CWE**: No data';
  const epssText = epss
    ? `- **EPSS**: ${epss.score?.toFixed(4)} (~${(epss.score * 100).toFixed(2)}% 30-day) ‚Äî Percentile ${(epss.percentile * 100).toFixed(1)}%`
    : '- **EPSS**: No data';
  const kevText = kevYes
    ? `- **CISA KEV**: ${cisaKevUrl(input)}${String(ransomwareTag).toLowerCase() === 'known' ? ' (Known ransomware campaign use)' : ''}`
    : `- **CISA KEV**: No`;
  return [
    `# ${isCVE ? input : `Analysis: ${input}`}`,
    ``,
    `## Executive Summary`,
    `${description || 'No CNA description available.'}`,
    ``,
    `## Root Cause & Vulnerable Components`,
    `- Derived from CNA/ADP/NVD records. (If not explicitly stated in the record, root cause details remain **unknown**.)`,
    `${cweText}`,
    ``,
    `## Exploitability`,
    `- Authentication requirements: **unknown**`,
    `- Network exposure: **unknown** (review service exposure, ingress rules, and public endpoints)`,
    `- PoC/weaponization: Consult Exploit-DB, PacketStorm, GitHub code searches in *Relevant Searches* panel.`,
    ``,
    `## Impact & Blast Radius`,
    `- Impact level per CVSS:`,
    `${cvssText}`,
    `- Key ATT&CK techniques: **Txxx (unknown)** ‚Äî map actual artifacts from detections once logs are available.`,
    ``,
    `## Detection Ideas`,
    `- Review application/server logs around suspected vulnerable components.`,
    `- Look for anomalous inputs aligned to CWE patterns (e.g., injection, deserialization).`,
    `- Enable verbose logging/telemetry for exposed services; monitor for IOCs from advisories.`,
    ``,
    `## Mitigation & Patch Priorities`,
    `- Apply vendor patches or mitigations referenced in CNA/NVD links.`,
    `- If patch unavailable: implement temporary compensating controls (WAF rules, service isolation).`,
    `- Prioritize based on KEV/EPSS:`,
    `${kevText}`,
    `${epssText}`,
    ``,
    `## Risk Scoring Rationale`,
    `- Based on the presence/absence of KEV, EPSS percentile, and CVSS base score.`,
    `- Adjust per asset exposure, business criticality, and observed exploitation in your environment.`,
    ``,
    `> Generated via static analysis mode (no external AI calls).`
  ].join('\n');
}
/* ---------- AI Analysis (Edge ‚Üí Gemini ‚Üí Enterprise ‚Üí Static) ---------- */
let __aiSession = null;
let __aiAbort = null;
function openAnalysisModal() { const m = document.getElementById('analysisModal'); const b = document.getElementById('analysisBody'); const s = document.getElementById('analysisStatus'); if (!m || !b || !s) return; b.textContent = ''; s.textContent = 'Preparing analysis‚Ä¶'; m.style.display = 'flex'; }
function closeAnalysisModal() { const m = document.getElementById('analysisModal'); if (m) m.style.display = 'none'; cancelAnalysis(); }
function cancelAnalysis() { try { if (__aiAbort) { __aiAbort.abort(); __aiAbort = null; } if (__aiSession?.destroy) { __aiSession.destroy(); } } catch {} __aiSession = null; }
function downloadAnalysis() { const text = document.getElementById('analysisBody')?.textContent || ''; const blob = new Blob([text], { type: 'text/markdown;charset=utf-8' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'analysis.md'; a.click(); URL.revokeObjectURL(a.href); }
async function runLocalAnalysis(prompt) {
  const body = document.getElementById('analysisBody'); const status = document.getElementById('analysisStatus');
  if (!('ai' in window) || !window.ai?.createTextSession) { throw new Error('Edge Prompt API unavailable'); }
  __aiSession = await window.ai.createTextSession({ systemPrompt: 'You are a security analyst. Be concise, technical, and explicitly note unknowns.', temperature: 0.2, topK: 40 });
  status.textContent = 'Generating locally (Edge)‚Ä¶';
  const supportsStreaming = !!__aiSession.promptStreaming;
  __aiAbort = new AbortController();
  if (supportsStreaming) { for await (const chunk of __aiSession.promptStreaming(prompt, { signal: __aiAbort.signal })) { body.textContent += chunk; } }
  else { body.textContent = await __aiSession.prompt(prompt); }
  status.textContent = 'Complete';
}
async function runAiAnalysis() {
  try {
    openAnalysisModal();
    const inputField = document.getElementById('cve')?.value || '';
    const ctx = __lastAnalysisContext || {
      input: inputField || 'unknown target',
      isCVE: /^CVE-\d{4}-\d{4,}$/i.test(inputField),
      cnaName: null,
      description: 'No description available yet',
      kevYes: false,
      ransomwareTag: 'Unknown',
      epss: null,
      cvss: [],
      cwes: [],
      referencesGrouped: []
    };
    const prompt = buildAnalysisPrompt(ctx);

    const body = document.getElementById('analysisBody');
    const status = document.getElementById('analysisStatus');

    // Only attempt browser-native window.ai (Edge/Copilot)
    if ('ai' in window && window.ai?.createTextSession) {
      try {
        status.textContent = 'Generating locally (browser AI)...';
        const session = await window.ai.createTextSession({
          systemPrompt: 'You are a security analyst. Be concise, technical, and explicitly note unknowns.',
          temperature: 0.2,
          topK: 40
        });

        const supportsStreaming = !!session.promptStreaming;
        if (supportsStreaming) {
          body.textContent = '';
          for await (const chunk of session.promptStreaming(prompt)) {
            body.textContent += chunk;
          }
        } else {
          body.textContent = await session.prompt(prompt);
        }
        status.textContent = 'Complete (local browser AI)';
        return;
      } catch (aiErr) {
        console.warn('Browser AI failed:', aiErr);
      }
    }

    // Fallback: static analysis
    body.textContent = generateStaticAnalysis(ctx);
    status.textContent = 'Static analysis (browser AI not available)';
  } catch (e) {
    console.error('AI Analysis error:', e);
    const status = document.getElementById('analysisStatus');
    const body = document.getElementById('analysisBody');
    if (status) status.textContent = 'Failed';
    if (body) body.textContent = `Error: ${e.message || 'Unexpected error'}`;
    toast('Analysis failed. Browser AI may not be supported in this browser.');
  }
}
function initInlineAnalysis() {
  const btn = document.getElementById('aiAnalysis'); const copyBtn = document.getElementById('analysisCopy');
  const saveBtn = document.getElementById('analysisSave'); const cancelBtn= document.getElementById('analysisCancel');
  const closeBtn = document.getElementById('analysisClose'); const modal = document.getElementById('analysisModal');
  if (btn) btn.onclick = runAiAnalysis;
  copyBtn?.addEventListener('click', async () => { try { const text = document.getElementById('analysisBody')?.textContent || ''; await navigator.clipboard.writeText(text); toast('Analysis copied to clipboard'); } catch { toast('Copy failed ‚Äî select and press Ctrl+C'); } });
  saveBtn?.addEventListener('click', downloadAnalysis);
  cancelBtn?.addEventListener('click', () => { cancelAnalysis(); toast('Analysis cancelled'); });
  closeBtn?.addEventListener('click', closeAnalysisModal);
  modal?.addEventListener('click', (e) => { if (e.target.id === 'analysisModal') closeAnalysisModal(); });
}
/* ---------- VulnCheck ---------- */
async function loadVulnCheck() {
  try {
    const res = await fetch('https://jakewarren.github.io/vulncheck-kev-rss/rss.xml');
    const text = await res.text(); const doc = new DOMParser().parseFromString(text, 'application/xml'); const items = doc.querySelectorAll('item');
    const now = Date.now(); let html = ""; __lastVulncheckRecent = [];
    items.forEach(item => {
      const pubDate = new Date(item.querySelector('pubDate')?.textContent || 0).getTime();
      if ((now - pubDate) < 10 * 24 * 60 * 60 * 1000) {
        const title = item.querySelector('title')?.textContent || ''; const link = item.querySelector('link')?.textContent || '#';
        const cveMatch = title.match(/CVE-\d{4}-\d{4,}/); const cve = cveMatch ? cveMatch[0] : 'Unknown CVE';
        const product = title.replace(cve, '').replace(/^\s*-\s*/, '').replace(/\s*Vulnerability.*$/i, '').trim() || 'Unknown Product';
        html += `<div class="item"><div class="title">${linkRow(link, cve + ' - ' + product)}</div></div>`;
        if (cveMatch) __lastVulncheckRecent.push(cve);
      }
    });
    document.getElementById("vulncheckContent").innerHTML = html || '<div class="meta">No recent additions in last 10 days.</div>';
  } catch { document.getElementById("vulncheckContent").innerHTML = '<div class="meta">Failed to load VulnCheck data.</div>'; }
}
/* ---------- KEV ---------- */
const KEV_JSON_URLS = [
  'https://raw.githubusercontent.com/cisagov/kev-data/develop/known_exploited_vulnerabilities.json',
  'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json',
  'https://corsproxy.io/?' + encodeURIComponent('https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json'),
  'https://api.allorigins.win/raw?url=' + encodeURIComponent('https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json')
];

// --- GLOBAL: CORS-tolerant text fetcher (single source of truth) ---
async function fetchTextWithFallback(url) {
  const attempts = [
    { name: 'direct',        getUrl: () => url },
    { name: 'corsproxy.io',  getUrl: () => `https://corsproxy.io/?${encodeURIComponent(url)}` },
    { name: 'allorigins',    getUrl: () => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}` },
    { name: 'jina',          getUrl: () => `https://r.jina.ai/${url.replace(/^https?:\/\//, '')}` }
  ];

  for (const attempt of attempts) {
    try {
      const res = await fetch(attempt.getUrl(), {
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Accept': 'application/json,text/plain,*/*' }
      });
      if (res.ok) {
        return await res.text();
      }
      console.warn(`${attempt.name} HTTP ${res.status}`);
    } catch (err) {
      console.warn(`${attempt.name} failed: ${err.message}`);
    }
  }
  throw new Error(`All fetch attempts failed for ${url}`);
}

let kevCache = { loaded: false, data: null, ts: 0 };

async function loadKEV() {
  // Cache: 60 minutes
  if (kevCache.loaded && kevCache.data && (Date.now() - kevCache.ts) < 60 * 60 * 1000) {
    console.log('KEV cache fresh');
    return kevCache.data;
  }

  for (const url of KEV_JSON_URLS) {
    try {
      const text = await fetchTextWithFallback(url);

      // Quick JSON sanity check: must start with '{' or '['
      const trimmed = (text || '').trim();
      if (!trimmed || !/^[\[{]/.test(trimmed)) {
        console.warn(`KEV ${url} returned non-JSON payload (${trimmed.slice(0, 60)}...)`);
        continue;
      }

      let json;
      try {
        json = JSON.parse(trimmed);
      } catch (parseErr) {
        console.warn(`KEV ${url} parse error: ${parseErr.message}`);
        continue;
      }

      const vulns = Array.isArray(json) ? json : (json.vulnerabilities || []);
      if (!Array.isArray(vulns)) {
        console.warn(`KEV ${url} unexpected structure ‚Äî no 'vulnerabilities' array`);
        continue;
      }

      kevCache = { loaded: true, data: vulns, ts: Date.now() };
      console.log(`KEV loaded (${vulns.length} entries)`);
      return vulns;
    } catch (err) {
      console.warn(`KEV ${url} failed: ${err.message}`);
    }
  }

  // Fallthrough: fail-safe
  kevCache = { loaded: true, data: [], ts: Date.now() };
  console.error('All KEV sources failed ‚Äî proceeding without KEV');
  return [];
}

// Keep this small helper as-is
function getKevEntry(cveId) {
  if (!kevCache.loaded || !kevCache.data) return null;
  const up = cveId.toUpperCase();
  return kevCache.data.find(e => (e.cveID || e.cveId || '').toUpperCase() === up) || null;
}
/* ---------- SSVC helpers ---------- */
/* [unchanged helpers: normalizeSsvcValue, capFirst, extractSsvcDeep] */
function normalizeSsvcValue(val) { return (val || 'N/A').toLowerCase().replace(/^(active|none|proof-of-concept|sporadic)$/i, m => m.toLowerCase()); }
function capFirst(str) { return (str || '').charAt(0).toUpperCase() + str.slice(1); }
function extractSsvcDeep(obj) {
  const decisionPoints = { exploitation: 'N/A', automatable: 'N/A', technicalImpact: 'N/A', decision: 'N/A' };
  if (typeof obj !== 'object' || !obj || !Array.isArray(obj.options)) return decisionPoints;

  obj.options.forEach(opt => {
    if (typeof opt !== 'object' || !opt) return;
    for (const key in opt) {
      const normKey = key.toLowerCase().replace(/\s+/g, '_');
      const val = opt[key];
      if (normKey === 'exploitation') decisionPoints.exploitation = normalizeSsvcValue(val);
      if (normKey === 'automatable') decisionPoints.automatable = normalizeSsvcValue(val);
      if (normKey === 'technical_impact') decisionPoints.technicalImpact = normalizeSsvcValue(val);
      if (normKey === 'decision') decisionPoints.decision = normalizeSsvcValue(val);
    }
  });

  return decisionPoints;
}
/* ---------- Vendor/Product helpers ---------- */
function tokensFromQuery(query) { return query.toLowerCase().split(/\s+/).filter(t => t.length > 1); }
function cpeTokensMatch(cpe, tokens) { if (!cpe) return false; const parts = cpe.toLowerCase().split(':'); return tokens.every(t => parts.some(p => p.includes(t))); }
function vulnMatchesTokens(vuln, tokens) { const desc = vuln?.cve?.descriptions?.[0]?.value?.toLowerCase() || ''; const refs = vuln?.cve?.references?.flatMap(r => r.url.toLowerCase() || []) || []; return tokens.every(t => desc.includes(t) || refs.some(u => u.includes(t))); }

// Global state for pagination (vendor/product mode only)
let vendorSearchState = {
  keyword: '',
  currentStartIndex: 0,
  totalResults: 0,
  resultsPerPage: 50,
  allVulns: []  // accumulate all loaded CVEs
};

// Add near vendorSearchState declaration
let previousVendorSearch = null;  // { keyword, allVulns, currentStartIndex, totalResults }  
  
/* ---------- NVD API Helpers ---------- */
async function fetchFromNVD(endpoint, params = {}) {
  const query = new URLSearchParams({
    ...params,
    resultsPerPage: params.resultsPerPage || 50
  }).toString();

  const url = `https://services.nvd.nist.gov/rest/json/${endpoint}?${query}`;
  console.log(`Fetching NVD: ${url}`);

  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`NVD HTTP ${res.status}`);
    return await res.json();
  } catch (err) {
    console.error(`NVD fetch error (${endpoint}):`, err);
    return { vulnerabilities: [], totalResults: 0, products: [] };
  }
}

async function fetchNvdCvesByKeyword(keyword, startIndex = 0) {
  return fetchFromNVD('cves/2.0', {
    keywordSearch: keyword,
    startIndex
    // pubStartDate removed ‚Äî lets API return all matching results by default
  });
}
  
async function fetchCPEs(keyword) {
  const data = await fetchFromNVD('cpes/2.0', {
    keywordSearch: keyword,
    resultsPerPage: 10
  });
  return data.products || [];
}
  
/* ---------- Rendering Helpers ---------- */
function getSeverityChip(score) {
  const sev = severityFromScore(score);
  const cls = classFromScore(score);
  return `<span class="chip ${cls}">${sev} (${score || 'N/A'})</span>`;
}

function getKevBadges(cveId) {
  if (!cveId || typeof cveId !== 'string' || !cveId.startsWith('CVE-')) return '';
  if (!kevCache.loaded || !Array.isArray(kevCache.data)) return ''; // ‚Üê guard

  const entry = getKevEntry(cveId);
  if (!entry || !entry.cveID) return '';

  let badges = `<span class="chip critical" style="background:#a60000; margin-left:8px;">KEV</span>`;
  if (String(entry.knownRansomwareCampaignUse).toLowerCase() === 'known') {
    badges += `<span class="chip yes" style="margin-left:4px;">Ransomware</span>`;
  }
  return badges;
}
  
function renderVendorProductResults(data, searchTerm = '', isAppend = false) {
  const vulns = data.vulnerabilities || [];
  const total = data.totalResults || vendorSearchState.totalResults;
  let html = '';

  // Update pagination state
  vendorSearchState.keyword = searchTerm;
  vendorSearchState.totalResults = total;
  vendorSearchState.currentStartIndex = data.startIndex + vulns.length;

  // Accumulate vulnerabilities
  if (!isAppend) {
    vendorSearchState.allVulns = [];
  }
  vendorSearchState.allVulns.push(...vulns);

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SORT HERE: newest published date first (descending)
  // We sort the accumulated list every time we render
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  vendorSearchState.allVulns.sort((a, b) => {
    const dateA = a.cve?.published ? new Date(a.cve.published) : new Date(0);
    const dateB = b.cve?.published ? new Date(b.cve.published) : new Date(0);
    return dateB - dateA;  // descending = newest first
  });

  // Header with total count
  if (total > 0) {
  const shown = vendorSearchState.allVulns.length;
  const more = shown < total ? ` (showing first ${shown} of ${total.toLocaleString()})` : '';
  html += `
    <div class="item" style="background:rgba(13,110,253,0.08); padding:12px; border-radius:8px; margin-bottom:16px;">
      <div class="title" style="font-size:1.1em;">
        Found ${total.toLocaleString()} CVEs for "${searchTerm}"${more}
      </div>
      <div class="meta" style="color:#0d6efd; font-weight:500;">
        Sorted: Newest published first ‚Ä¢ ${shown} displayed
      </div>
    </div>`;
  
    if (total < 20) {
      html += `<div class="meta" style="color:#e65100; margin-bottom:12px;">
        (Few results ‚Äî try more specific terms like "${searchTerm} Server")
      </div>`;
    }
  } else {
    html += '<div class="meta">No matching vulnerabilities found.</div>';
  }

  // Render the now-sorted items
  vendorSearchState.allVulns.forEach(vuln => {
  const cve = vuln?.cve || {};
  const id = cve.id || 'Unknown';
  const desc = cve.descriptions?.[0]?.value || 'No description';
  const published = cve.published ? new Date(cve.published).toLocaleDateString() : '‚Äî';
  const score = cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore ||
                cve.metrics?.cvssMetricV40?.[0]?.cvssData?.baseScore || 0;

  html += `
    <div class="item">
      <div class="title">
        <a href="#" class="cve-link" data-cve="${id}" style="color: var(--link-light); font-weight: 600;">
          ${id}
        </a>
        ${getSeverityChip(score)} ${getKevBadges(id) || ''}
      </div>
      <div class="meta">
        Published: ${published}<br>
        ${desc.substring(0, 180)}${desc.length > 180 ? '...' : ''}
      </div>
    </div>`;
  });

  const content = document.getElementById('cveContent');
  if (isAppend) {
    content.innerHTML += html;
  } else {
    content.innerHTML = html;
  }

  // Load more button logic
  const hasMore = vendorSearchState.allVulns.length < total;
  let btn = document.getElementById('loadMoreBtn');
  if (hasMore && !btn) {
    btn = document.createElement('button');
    btn.id = 'loadMoreBtn';
    btn.className = 'btn';
    btn.textContent = 'Load more (50 more)';
    btn.style.marginTop = '16px';
    btn.onclick = loadNextPage;
    content.appendChild(btn);
  } else if (btn) {
    btn.style.display = hasMore ? 'block' : 'none';
    btn.textContent = hasMore ? 'Load more (50 more)' : 'All loaded';
  }

  renderRelevantSearches(searchTerm);
}

async function loadNextPage() {
  const { keyword, currentStartIndex } = vendorSearchState;
  if (!keyword) return;

  const loadingEl = document.getElementById("loading");
  if (loadingEl) loadingEl.style.display = "flex";

  try {
    // Show delay message if using rate-limit delay
    // toast("Waiting 6 seconds for NVD rate limit...");  // optional

    // Uncomment if no API key
    // await new Promise(resolve => setTimeout(resolve, 6000));

    const data = await fetchNvdCvesByKeyword(keyword, currentStartIndex);
    renderVendorProductResults(data, keyword, true);
  } catch (err) {
    console.error("Pagination fetch error:", err);
    toast("Failed to load more results");
  } finally {
    if (loadingEl) loadingEl.style.display = "none";
  }
}

async function runVendorProductSearch(keyword) {
  if (!keyword || typeof keyword !== 'string' || keyword.trim() === '') {
    toast("Invalid search term for vendor/product");
    return;
  }
  const trimmedKeyword = keyword.trim();
  console.log("Vendor/Product search started for:", trimmedKeyword);
  const words = trimmedKeyword.split(/\s+/).filter(w => w.length > 0);
  const wordCount = words.length;
  vendorSearchState = {
    keyword: trimmedKeyword,
    currentStartIndex: 0,
    totalResults: 0,
    resultsPerPage: 50,
    allVulns: []
  };
  const loadingEl = document.getElementById("loading");
  if (loadingEl) loadingEl.style.display = "flex";
  try {
    // Single-word = broad ‚Üí show warning + web link only
    if (wordCount === 1) {
      const webQuery = encodeURIComponent(trimmedKeyword);
      const nvdWebUrl = `https://nvd.nist.gov/vuln/search/results?form_type=Basic&results_type=overview&query=${webQuery}&search_type=all`;
      const fallbackHtml = `
        <div class="item" style="background:rgba(255,193,7,0.1); padding:16px; border-radius:8px;">
          <div class="title" style="font-size:1.2em; color:#e65100;">Broad search detected</div>
          <div class="meta" style="margin-top:12px;">
            Single-word searches like "${trimmedKeyword}" are too broad for the NVD API.<br><br>
            <a href="${nvdWebUrl}" target="_blank" style="color:#0d6efd; font-weight:bold;">
              Open full NVD web search for "${trimmedKeyword}" (recommended)
            </a><br>
            (usually shows hundreds or thousands of results)
          </div>
        </div>
        <div class="meta" style="margin-top:16px;">
          Tip: Try adding a product/version (e.g., "${trimmedKeyword} Server", "${trimmedKeyword} 7")
        </div>
      `;
      document.getElementById("cveContent").innerHTML = fallbackHtml;
      renderRelevantSearches(trimmedKeyword);
      await renderRelevantSearches(trimmedKeyword);
      toast("Single-word search ‚Äî showing NVD web link instead");
      console.log("Broad single-word fallback:", nvdWebUrl);
    } else {
      // 2+ words ‚Üí use API
      const data = await fetchNvdCvesByKeyword(trimmedKeyword, 0);
      console.log("CVE response:", {
        total: data.totalResults,
        returned: data.vulnerabilities?.length || 0,
        first: data.vulnerabilities?.[0]?.cve?.id || "none"
      });
      // Always render results
      renderVendorProductResults(data, trimmedKeyword, false);
      // Add advisory if low count
      if (data.totalResults <= 50 && data.totalResults > 0) {
        const webQuery = encodeURIComponent(trimmedKeyword);
        const nvdWebUrl = `https://nvd.nist.gov/vuln/search/results?form_type=Basic&results_type=overview&query=${webQuery}&search_type=all`;
        const advisoryHtml = `
          <div class="item" style="background:rgba(255,193,7,0.1); padding:16px; border-radius:8px; margin-bottom:16px;">
            <div class="title" style="font-size:1.2em; color:#e65100;">Limited API Results (${data.totalResults})</div>
            <div class="meta" style="margin-top:12px;">
              The NVD API only found ${data.totalResults} matches for "${trimmedKeyword}".<br>
              Broad or common terms sometimes return few results in the API.<br><br>
              <a href="${nvdWebUrl}" target="_blank" style="color:#0d6efd; font-weight:bold;">
                View full NVD web search results here
              </a><br>
              (often shows many more entries)
            </div>
          </div>
        `;
        const content = document.getElementById("cveContent");
        content.insertAdjacentHTML('afterbegin', advisoryHtml);
        toast(`Only ${data.totalResults} results ‚Äî web link added for more`);
      }
      renderRelevantSearches(trimmedKeyword);
      + await renderRelevantSearches(trimmedKeyword);
    }
  } catch (err) {
    console.error("Search failed:", err);
    document.getElementById("cveContent").innerHTML = `
      <div class="meta">Error: ${err.message || 'NVD service issue'}. Try a different term.</div>
    `;
    renderRelevantSearches(trimmedKeyword);
    + await renderRelevantSearches(trimmedKeyword);
  } finally {
    if (loadingEl) loadingEl.style.display = "none";
  }
}
/* ---------- CVE flow ---------- */
/* [unchanged: isCVE, runSearch] */
function isCVE(str){ return /^CVE-\d{4}-\d{4,}$/i.test(str); }
async function runSearch() {
  const inputRaw = (document.getElementById("cve")?.value || "").trim();
  const input = inputRaw.toUpperCase();
  // If not CVE, delegate to vendor/product search
  if (!isCVE(input)) {
    if (inputRaw.length < 2) {
      toast("Enter at least 2 characters for vendor/product search");
      return;
    }
    return runVendorProductSearch(inputRaw);
  }
  // Show loading overlay
  const loadingEl = document.getElementById("loading");
  if (loadingEl) loadingEl.style.display = "flex";
  try {
    // Fetch CNA (CVE Services), NVD, EPSS in parallel
    const [cveRes, nvdRes, epssRes] = await Promise.all([
      fetch(`https://cveawg.mitre.org/api/cve/${input}`),
      fetch(`https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${input}`),
      fetch(`https://api.first.org/data/v1/epss?cve=${input}`)
    ]);
    if (!cveRes.ok) throw new Error("CVE not found");
    // KEV / Ransomware tag
    const kevEntry = getKevEntry(input);
    const kevYes = !!kevEntry;
    const ransomwareTag = kevEntry ? (kevEntry.knownRansomwareCampaignUse || 'Unknown') : 'Unknown';
    // CNA record
    const cveData = await cveRes.json();
    const cna = cveData?.containers?.cna || {};
    const desc = cna?.descriptions?.[0]?.value || "No description";
    const cnaName = cna?.providerMetadata?.shortName || "Unknown";
    const adpProviders = Array.isArray(cveData?.containers?.adp) ? cveData.containers.adp : [];
    const published = cveData.cveMetadata?.datePublished ? new Date(cveData.cveMetadata.datePublished).toLocaleDateString() : 'N/A';
    // SSVC block (best effort)
    let ssvcInlineHtml = '';
    try {
      const allMetrics = (adpProviders || []).flatMap(p => (p.metrics || []).map(m => ({ provider:p, metric:m })));
      const ssvcMetricEntry =
        allMetrics.find(({provider, metric}) =>
          (provider?.providerMetadata?.shortName || '').toLowerCase().includes('cisa') &&
          metric?.other && String(metric.other.type || '').toLowerCase() === 'ssvc'
        ) ||
        allMetrics.find(({metric}) => metric?.other && String(metric.other.type || '').toLowerCase() === 'ssvc');
      const ssvcContent = ssvcMetricEntry?.metric?.other?.content;
      const parsed = extractSsvcDeep(ssvcContent);
      const exploitation = capFirst(parsed.exploitation);
      const automatable = capFirst(parsed.automatable);
      const technicalImpact = capFirst(parsed.technicalImpact);
      const decision = capFirst(parsed.decision);
      const providerName = ssvcMetricEntry?.provider?.providerMetadata?.shortName || 'ADP';
      ssvcInlineHtml = `
        <div class="metrics-box">
          <div class="title">SSVC Metrics (${providerName})</div>
          <table>
            <tr><th>Exploitation</th><td>${exploitation}</td></tr>
            <tr><th>Automatable</th><td>${automatable}</td></tr>
            <tr><th>Technical Impact</th><td>${technicalImpact}</td></tr>
            ${decision !== 'N/A' ? `<tr><th>Decision</th><td>${decision}</td></tr>` : ''}
          </table>
        </div>`;
      if (!ssvcMetricEntry || !ssvcContent) {
        ssvcInlineHtml = `
        <div class="metrics-box">
          <div class="title">SSVC Decision Points</div>
          <table><tr><th>Status</th><td>No SSVC Data is Available at this time.</td></tr></table>
        </div>`;
      }
    } catch {
      ssvcInlineHtml = `
      <div class="metrics-box">
        <div class="title">SSVC Decision Points</div>
        <table><tr><th>Status</th><td>No SSVC Data is Available at this time.</td></tr></table>
      </div>`;
    }
    // EPSS block
    const epssData = epssRes.ok ? (await epssRes.json()).data?.[0] : null;
    const epssDateStr = epssData?.date ? `(as of ${new Date(epssData.date).toLocaleString()})` : '';
    const epssInlineHtml = epssData ? `
      <div class="metrics-box">
        <div class="title">EPSS Metrics</div>
        <table>
          <tr><th>EPSS Score</th><td>${Number(epssData.epss).toFixed(4)} ${epssDateStr}</td></tr>
          <tr><th>30-day Probability</th><td>${(Number(epssData.epss) * 100).toFixed(2)}% ${epssDateStr}</td></tr>
          <tr><th>Percentile</th><td>${(Number(epssData.percentile) * 100).toFixed(1)}% ${epssDateStr}</td></tr>
        </table>
      </div>` : `
      <div class="metrics-box">
        <div class="title">EPSS Metrics</div>
        <table><tr><th>Status</th><td>No EPSS data available</td></tr></table>
      </div>`;
    // References (by host) from CNA
    const refs = (cna.references || []).filter(r => r.url && r.url.startsWith('https://'));
    const grouped = refs.reduce((acc, r) => {
      let host;
      try { host = new URL(r.url).hostname.replace(/^www\./,''); } catch { host = "link"; }
      (acc[host] ||= []).push(r);
      return acc;
    }, {});
    const refsHtml = Object.keys(grouped).map(host => {
      const list = grouped[host];
      return `<div class="item"><div class="title">${host} (${list.length})</div><div class="meta">${ list.map(r => linkRow(r.url, r.name || r.url)).join("") }</div></div>`;
    }).join("") || '<div class="meta">No references found.</div>';
    document.getElementById("sourcesContent").innerHTML = refsHtml;
    // CVSS metrics (CNA + NVD)
    const metrics = [];
    (cna.metrics || []).forEach(m => {
      if (m.cvssV3_1) metrics.push({score:m.cvssV3_1.baseScore, version:"3.1", source:`CVE.org - CNA (${cnaName})`, vector:m.cvssV3_1.vectorString});
      if (m.cvssV4_0) metrics.push({score:m.cvssV4_0.baseScore, version:"4.0", source:`CVE.org - CNA (${cnaName})`, vector:m.cvssV4_0.vectorString});
    });
    let nvdJson = null;
    if (nvdRes.ok) {
      nvdJson = await nvdRes.json();
      const nvdCve = nvdJson.vulnerabilities?.[0]?.cve;
      if (nvdCve?.metrics) {
        ["cvssMetricV31","cvssMetricV40"].forEach(key => {
          (nvdCve.metrics[key] || []).forEach(m => {
            const data = m.cvssData;
            if (data) metrics.push({ score:data.baseScore, version: key==="cvssMetricV31"?"3.1":"4.0", source:"NVD - NIST", vector:data.vectorString });
          });
        });
      }
    }
    const cvssHtml = metrics.map(m => {
      const sev = (m.score<4?"Low":m.score<7?"Medium":m.score<9?"High":"Critical");
      const cls = (m.score<4?"low":m.score<7?"medium":m.score<9?"high":"critical");
      return `<div class="item"><div class="title">CVSS v${m.version} ‚Äì ${m.score} <span class="chip ${cls}">${sev}</span></div><div class="meta">Source: ${m.source}<br>Vector: ${m.vector || "N/A"}</div></div>`;
    }).join("") || '<div class="meta">No CVSS metrics available</div>';
    const inVulncheck = __lastVulncheckRecent.includes(input);
const quickLinksHtml = [
  linkRow(`https://nvd.nist.gov/vuln/detail/${input}`, "NVD Detail Page"),
  linkRow(`https://cve.mitre.org/cgi-bin/cvename.cgi?name=${input}`, "MITRE CVE Record"),
  linkRow(`https://cveawg.mitre.org/api/cve/${input}`, "CVE Services JSON"),
  kevYes ? linkRow(cisaKevUrl(input), "CISA KEV Catalog (this CVE)") : '',
  linkRow(`https://web.archive.org/`, "Archive.org (Wayback Machine)")
].join("<br>");
    // Always show relevant searches
    renderRelevantSearches(input);
    await renderRelevantSearches(input);
    if (String(ransomwareTag).toLowerCase()==='known') renderRansomwareSearches(input);
    const cweHtml = buildCweHtml(cveData, nvdJson);
    // Context for AI Analysis
    const referencesGrouped = Object.keys(grouped).map(host => ({
      host,
      links: grouped[host].map(r => ({ name: r.name || r.url, url: r.url }))
    }));
    const cvssForPrompt = metrics.map(m => ({ version: m.version, score: m.score, source: m.source, vector: m.vector }));
    const cwesForPrompt = (cna?.problemTypes || [])
      .flatMap(pt => (pt.descriptions || []).map(d => ({ id: d?.cweId || d?.id || 'Unknown', desc: d?.description || d?.value || '', assigner: cna?.providerMetadata?.shortName || 'CNA' })));
    __lastAnalysisContext = {
      input,
      isCVE: true,
      cnaName,
      description: desc,
      kevYes,
      ransomwareTag,
      epss: epssData ? { score: Number(epssData.epss), percentile: Number(epssData.percentile) } : null,
      cvss: cvssForPrompt,
      cwes: cwesForPrompt,
      referencesGrouped
    };
    // Paint CVE panel
    const cveContent = document.getElementById("cveContent");
    cveContent.innerHTML = `
      <div class="item"><div class="title">${input} ¬∑ CNA: ${cnaName}</div></div>
      <div class="item"><div class="title">Published: ${published}</div></div>
      <div class="item"><div class="title">Description</div><div class="meta">${desc}</div></div>
      <div class="item">
      <div class="title">Exploitation Signals</div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;">
      <div class="badge ${kevYes ? 'yes' : 'no'}">CISA KEV: ${kevYes ? 'Yes' : 'No'}</div>
        ${kevYes ? `<div class="badge ${String(ransomwareTag).toLowerCase()==='known' ? 'yes' : 'no'}">Ransomware: ${ransomwareTag}</div>` : `<div class="badge no">Ransomware: Unknown</div>`}
        ${inVulncheck ? '<div class="badge yes">VulnCheck Recent</div>' : ''}
      </div>
        <div class="metrics-row">
          <div class="metrics-col">${epssInlineHtml}</div>
          <div class="metrics-col">${ssvcInlineHtml}</div>
        </div>
      </div>
      <div class="item"><div class="title">CWE Information</div><div class="meta">${cweHtml}</div></div>
      <div class="item"><div class="title">CVSS Metrics</div><div class="meta">${cvssHtml}</div></div>
      <div class="item"><div class="title">Quick Links</div><div class="meta">${quickLinksHtml}</div></div>
    `;
  } catch (err) {
    document.getElementById("cveContent").innerHTML = `<div class="meta">Error loading data: ${err.message}</div>`;
    renderRelevantSearches(inputRaw);
  } finally {
    if (loadingEl) loadingEl.style.display = "none";
  }
}
/* ---------- Exploitation Watch ---------- */
async function fetchTextWithBetterFallback(url) {
  const proxies = [
    url => url,                               // direct first
    url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
    url => `https://corsproxy.io/?${encodeURIComponent(url)}`,  // new free proxy
    url => `https://r.jina.ai/${url}`,        // drop http:// prefix if needed
  ];

  for (const proxy of proxies) {
    try {
      const target = proxy(url);
      const res = await fetch(target, { mode: 'cors', cache: 'no-store' });
      if (res.ok) return await res.text();
    } catch (e) {
      console.warn(`Proxy ${proxy.name || 'direct'} failed for ${url}:`, e);
    }
  }
  throw new Error(`All proxies failed for ${url}`);
}
async function loadExploitationWatch() {
  const now = Date.now(); const tenDaysMs = 10*24*60*60*1000; let out=[];
  const sources = [
  { name:"0patch Blog", url:"https://blog.0patch.com/feeds/posts/default" },
  { name:"Anton on Security (Medium)", url:"https://medium.com/feed/anton-on-security" },
  { name:"Ars Technica ‚Äì Security", url:"https://arstechnica.com/tag/security/feed/" },
  { name:"ASEC (AhnLab) Blog", url:"https://asec.ahnlab.com/en/feed/" },
  { name:"AWS Security Blog", url:"https://aws.amazon.com/blogs/security/feed/" },
  { name:"Bitdefender Labs", url:"https://www.bitdefender.com/nuxt/api/en-us/rss/labs/" },
  { name:"BleepingComputer", url:"https://www.bleepingcomputer.com/feed/" },
  { name:"Broadcom/Symantec Enterprise Blogs", url:"https://sed-cms.broadcom.com/rss/v1/blogs/rss.xml" },
  { name:"Center for Internet Security ‚Äì Advisories", url:"https://www.cisecurity.org/feed/advisories" },
  { name:"CERT/CC Vulnerability Notes", url:"https://www.cisa.gov/cybersecurity-advisories/cybersecurity-advisories.xml" },
  { name:"Check Point Research", url:"https://research.checkpoint.com/feed/" },
  { name:"CISA Cybersecurity Advisories (All)", url:"https://www.cisa.gov/sites/default/files/feeds/alerts.xml" },
  { name:"CISA ICS Advisories", url:"https://www.cisa.gov/sites/default/files/feeds/ics-advisories.xml" },
  { name:"CISA ICS Medical Advisories", url:"https://www.cisa.gov/sites/default/files/feeds/ics-medical-advisories.xml" },
  { name:"Cisco Security Blog", url:"https://blogs.cisco.com/security/feed" },
  { name:"Cisco Talos Intelligence", url:"https://blog.talosintelligence.com/rss/" },
  { name:"Cloudflare Blog", url:"https://blog.cloudflare.com/rss/" },
  { name:"CloudSec (Google Cloud) Threat Intelligence", url:"https://cloudblog.withgoogle.com/topics/threat-intelligence/rss/" },
  { name:"Cofense", url:"https://cofense.com/feed/" },
  { name:"CrowdStrike Blog", url:"https://www.crowdstrike.com/en-us/blog/feed" },
  { name:"Cyble", url:"https://cyble.com/feed/" },
  { name:"Cybereason Blog", url:"https://www.cybereason.com/blog/rss.xml" },
  { name:"Dark Reading", url:"https://www.darkreading.com/rss.xml" },
  { name:"Darktrace Blog", url:"https://www.darktrace.com/blog/rss.xml" },
  { name:"DFIR Report", url:"https://thedfirreport.com/feed/" },
  { name:"DuskRise", url:"https://www.duskrise.com/feed/" },
  { name:"EclecticIQ", url:"https://blog.eclecticiq.com/rss.xml" },
  { name:"Exploit Database", url:"https://www.exploit-db.com/rss.xml" },
  { name:"Forescout", url:"https://www.forescout.com/feed/" },
  { name:"Fox-IT Blog", url:"https://blog.fox-it.com/feed/" },
  { name:"GBHackers", url:"https://gbhackers.com/feed/" },
  { name:"Google Online Security Blog", url:"https://feeds.feedburner.com/GoogleOnlineSecurityBlog" },
  { name:"Google TAG (Threat Analysis Group)", url:"https://blog.google/threat-analysis-group/rss/" },
  { name:"Graham Cluley", url:"https://grahamcluley.com/feed/" },
  { name:"Group-IB Blog", url:"https://www.group-ib.com/feed/blogfeed/" },
  { name:"Hackmageddon", url:"https://www.hackmageddon.com/feed/" },
  { name:"HackRead", url:"https://hackread.com/feed/" },
  { name:"Help Net Security", url:"https://www.helpnetsecurity.com/feed/" },
  { name:"HP Threat Research (HP Wolf Security)", url:"https://threatresearch.ext.hp.com/feed/" },
  { name:"Infoblox ‚Äì Threat Intelligence", url:"https://www.infoblox.com/blog/category/threat-intelligence/feed/" },
  { name:"Infosecurity Magazine ‚Äì News", url:"https://www.infosecurity-magazine.com/rss/news/" },
  { name:"Intego Mac Security Blog", url:"https://www.intego.com/mac-security-blog/feed/" },
  { name:"Intezer", url:"https://intezer.com/feed/" },
  { name:"Juniper Threat Research", url:"https://blogs.juniper.net/threat-research/feed" },
  { name:"Krebs on Security", url:"https://krebsonsecurity.com/feed/" },
  { name:"Lab52", url:"https://lab52.io/blog/feed/" },
  { name:"LevelBlue ‚Äì SpiderLabs Blog", url:"https://levelblue.com/blogs/spiderlabs-blog/rss.xml" },
  { name:"Malware Traffic Analysis (canonical)", url:"https://www.malware-traffic-analysis.net/blog-entries.rss" },
  { name:"Malwarebytes Labs", url:"https://www.malwarebytes.com/blog/feed/index.xml" },
  { name:"McAfee ‚Äì Advanced Threat Research", url:"https://www.mcafee.com/blogs/tag/advanced-threat-research/feed/" },
  { name:"McAfee ‚Äì Labs", url:"https://www.mcafee.com/blogs/other-blogs/mcafee-labs/feed/" },
  { name:"McAfee ‚Äì All Blogs", url:"https://www.mcafee.com/blogs/feed" },
  { name:"Microsoft Security Blog", url:"https://www.microsoft.com/security/blog/feed/" },
  { name:"Morphisec", url:"https://www.morphisec.com/feed/?post_type=blog" },
  { name:"Moonlock", url:"https://moonlock.com/feed" },
  { name:"MSRC Security Update Guide", url:"https://api.msrc.microsoft.com/update-guide/rss" },
  { name:"nao_sec (Research Team)", url:"https://nao-sec.org/feed" },
  { name:"NIST ‚Äì Cybersecurity Insights", url:"https://www.nist.gov/blogs/cybersecurity-insights/rss.xml" },
  { name:"Palo Alto Networks ‚Äì Main Blog", url:"https://www.paloaltonetworks.com/blog/feed/" },
  { name:"Palo Alto Networks ‚Äì Unit 42", url:"https://www.paloaltonetworks.com/blog/unit42/feed/" },
  { name:"Permiso", url:"https://permiso.io/blog/rss.xml" },
  { name:"PhishLabs", url:"https://www.phishlabs.com/feed" },
  { name:"Project Zero", url:"https://projectzero.google/feed.xml" },
  { name:"Proofpoint", url:"https://www.proofpoint.com/us/rss.xml" },
  { name:"Qualys Blog", url:"https://blog.qualys.com/feed" },
  { name:"Quarkslab", url:"https://blog.quarkslab.com/feeds/all.rss.xml" },
  { name:"Quick Heal Blog", url:"https://www.quickheal.com/blogs/feed/" },
  { name:"Rapid7 Blog", url:"https://www.rapid7.com/rss.xml" },
  { name:"Recorded Future Blog", url:"https://www.recordedfuture.com/blog/rss" },
  { name:"Reddit r/cybersecurity", url:"https://www.reddit.com/r/cybersecurity/.rss" },
  { name:"Reddit r/netsec", url:"https://www.reddit.com/r/netsec/.rss" },
  { name:"Rewterz", url:"https://rewterz.com/feed" },
  { name:"Risky Business Podcast", url:"https://risky.biz/rss/podcast/" },
  { name:"SANS Internet Storm Center (ISC Diary)", url:"https://isc.sans.edu/rssfeed_full.xml" },
  { name:"Schneier on Security (Cybersecurity tag)", url:"https://www.schneier.com/tag/cybersecurity/feed/" },
  { name:"Securelist (Kaspersky)", url:"https://securelist.com/feed/" },
  { name:"Security Affairs", url:"https://securityaffairs.com/feed" },
  { name:"Security Joes", url:"https://www.securityjoes.com/blog-feed.xml" },
  { name:"SecurityWeek", url:"https://www.securityweek.com/feed/" },
  { name:"SensePost", url:"https://sensepost.com/rss.xml" },
  { name:"SentinelOne Labs", url:"https://www.sentinelone.com/labs/feed/" },
  { name:"Silent Push", url:"https://www.silentpush.com/feed/" },
  { name:"SOC Prime", url:"https://socprime.com/blog/feed/" },
  { name:"SOCRadar", url:"https://socradar.io/feed/" },
  { name:"The Guardian ‚Äì Data & Computer Security", url:"https://www.theguardian.com/technology/data-computer-security/rss" },
  { name:"The Hacker News", url:"https://feeds.feedburner.com/TheHackersNews" },
  { name:"The Register ‚Äì Security Headlines", url:"https://www.theregister.com/security/headlines.rss" },
  { name:"Therecord.media", url:"https://therecord.media/feed" },
  { name:"ThreatMon", url:"https://threatmon.io/feed/" },
  { name:"Trend Micro (Simply Security)", url:"http://feeds.trendmicro.com/TrendMicroSimplySecurity" },
  { name:"Tripwire", url:"https://www.tripwire.com/blogs.xml" },
  { name:"Troy Hunt Blog", url:"https://www.troyhunt.com/rss/" },
  { name:"Unit 42 (legacy v2 feed)", url:"https://unit42.paloaltonetworks.com/feed/?v=2" },
  { name:"UpGuard ‚Äì Breaches", url:"https://www.upguard.com/breaches/rss.xml" },
  { name:"UpGuard ‚Äì News", url:"https://www.upguard.com/news/rss.xml" },
  { name:"Virus Bulletin", url:"https://www.virusbulletin.com/rss" },
  { name:"VirusTotal Blog", url:"https://blog.virustotal.com/feeds/posts/default" },
  { name:"Volexity", url:"https://www.volexity.com/feed/" },
  { name:"Webroot Blog", url:"https://www.webroot.com/blog/feed/" },
  { name:"WeLiveSecurity (ESET)", url:"https://www.welivesecurity.com/feed/" },
  { name:"WeLiveSecurity (ESET ‚Äì English site feed)", url:"https://www.welivesecurity.com/en/rss/feed/" },
  { name:"WIRED ‚Äì Security", url:"https://www.wired.com/feed/category/security/latest/rss" },
  { name:"Wiz ‚Äì Cloud Threat Landscape", url:"https://www.wiz.io/api/feed/cloud-threat-landscape/rss.xml" },
  { name:"ZDNet ‚Äì News", url:"https://www.zdnet.com/news/rss.xml" },
  { name:"Zero Day Initiative ‚Äì Published", url:"https://www.zerodayinitiative.com/rss/published/" },
  { name:"Zscaler ‚Äì Security Research", url:"https://www.zscaler.com/blogs/feeds/security-research" }
  ];
  const exploitationCue =(text)=>/\b(exploit(?:ed|ing)?|weaponiz(?:ed|ation)|PoC|proof[-\s]of[-\s]concept|RCE|in the wild|actively targeted|advisory|zero[-\s]?day)\b/i.test(text||"");
  const hasCve =(text)=>/\bCVE-\d{4}-\d{4,}\b/i.test(text||"");
  function withinTenDays(dateStr){ const t=new Date(dateStr||0).getTime(); return isFinite(t) && (now-t)<tenDaysMs; }
  async function collectRss(url, sourceName){
    try{
      const xml = await fetchTextWithFallback(url);
      const doc = new DOMParser().parseFromString(xml,"application/xml");
      const items = Array.from(doc.querySelectorAll("item, entry")).slice(0,60);
      items.forEach(item=>{
        const pick = sel => item.querySelector(sel)?.textContent || '';
        const title = pick("title");
        const desc = pick("description") || pick("summary");
        const linkNode = item.querySelector('link[href]');
        const link = (item.querySelector("link")?.textContent || linkNode?.getAttribute('href') || "#").trim();
        const pub = pick("pubDate") || pick("updated");
        if (withinTenDays(pub) && (hasCve(title+" "+desc) || exploitationCue(title+" "+desc))) {
          out.push({ source:sourceName, title, link, date:new Date(pub).toLocaleString() });
        }
      });
    }catch{}
  }
  document.getElementById("watchContent").innerHTML = '<div class="meta">Loading feeds‚Ä¶</div>';
  await Promise.all(sources.map(s=>collectRss(s.url,s.name)));
  out.sort((a,b)=> new Date(b.date||0) - new Date(a.date||0));
  const html = out.map(r=>`<div class="item"><div class="title">${linkRow(r.link, r.title)}</div><div class="meta">${r.source}${r.date ? ' ¬∑ ' + r.date : ''}</div></div>`).join("");
  const watchContent = document.getElementById("watchContent");
  watchContent.innerHTML = html || '<div class="meta">No recent exploitation reports detected in the last 10 days from selected sources.</div>';
  if (out.length > 10) {
    watchContent.style.overflowY = 'auto';
    watchContent.style.maxHeight = '320px';
  } else {
    watchContent.style.overflowY = '';
    watchContent.style.maxHeight = '';
  }
}
/* ---------- Prevalence ---------- */
function renderPrevalenceSignals(keyword){ document.getElementById("prevBody").innerHTML = `<div class="meta">Prevalence view not enabled in this build.</div>`; }
function openPrevalence(keyword){ const modal=document.getElementById("prevalenceModal"); if(!modal) return toast("Prevalence modal is not available."); modal.style.display="flex"; document.getElementById("prevTitle").textContent=`Prevalence ‚Äì ${keyword}`; renderPrevalenceSignals(keyword); }
/* ---------- Relevant Searches ---------- */
async function renderRelevantSearches(term) {

async function renderRelevantSearches(term) {
  const container = document.getElementById("searchLinks");
  if (!container) return;

  const q = encodeURIComponent(term);
  const isCve = /^CVE-\d{4}-\d{4,}$/i.test(term);

  container.innerHTML = '<div class="meta">Checking relevant sources‚Ä¶</div>';

  const SOURCES = [
    { label: "Exploit-DB Search", url: `https://www.exploit-db.com/search?q=${q}`,
      test: (html) => /\/exploits\/\d+/.test(html) && !/No results|did not match any results/i.test(html) },
    { label: "PacketStorm Search", url: `https://packetstorm.news/files/cve/?q=${q}`,
      test: (html) => /\/files\/\d+\//.test(html) && !/No files matched/i.test(html) },
    { label: "GitHub Code Search (PoCs)", url: `https://github.com/search?q=${q}&type=code`,
      test: (html) => /data-total-count="(\d+)"/i.test(html)
        || (!/We couldn‚Äôt find any code/i.test(html) && /aria-label="Code"/i.test(html)) },
    ...(isCve ? [{ label: "CrowdSec CTI Explorer",
                   url: `https://app.crowdsec.net/cti/cve-explorer/${term.toLowerCase()}`,
                   test: (html) => /CVE-\d{4}-\d{4,}/i.test(html) }] : []),
    { label: "X (Twitter) Latest", url: `https://x.com/search?q=${q}&f=live`, skipFetch: true },
    { label: "BleepingComputer", url: `https://www.bleepingcomputer.com/search/?q=${q}`,
      test: (html) => /class=["']?search-result/i.test(html) && !/No results/i.test(html) },
    { label: "The Hacker News", url: `https://thehackernews.com/search?q=${q}`,
      test: (html) => /<article|class=["']post-title/i.test(html) }
  ];

  const timeout = (ms, promise) =>
    Promise.race([ promise, new Promise((resolve) => setTimeout(() => resolve(null), ms)) ]);

  // Defensive timeout so a single slow site doesn‚Äôt stall the panel
  const timeout = (ms, p) =>
    Promise.race([p, new Promise((resolve) => setTimeout(() => resolve(null), ms))]);

  async function probeSource(src) {
    if (src.skipFetch) return { src, ok: false }; // don't use as signal
    try {
      const html = await timeout(6000, fetchTextWithBetterFallback(src.url));
      const ok = !!html && typeof src.test === "function" && src.test(html);
      return { src, ok };
    } catch {
      return { src, ok: false };
    }
  }

  // Run probes in parallel
  const probes = Promise.all(SOURCES.map(probeSource));
  const matched = probes.filter((p) => p.ok);

  if (!matched.length) {
    // Your requirement: show nothing unless we have info to return
    container.innerHTML = `<div class="meta">No matching hits were found on common sources for ‚Äú${term}‚Äù.</div>`;
    return;
  }

  // Render only matched sources; add X (Twitter) link as a convenience if we had any hits
  const rows = matched.map(({ src }) => linkRow(src.url, src.label));
  const twitter = SOURCES.find((s) => s.skipFetch);
  if (twitter) rows.push(linkRow(twitter.url, twitter.label));

  container.innerHTML = `
    <div class="item">
      <div class="title">Relevant Searches</div>
      <div class="meta">${rows.join("<br>")}</div>
    </div>`;
}
function renderRansomwareSearches(cveId){
  const q = encodeURIComponent(cveId + " ransomware");
  const rows = [
    linkRow(`https://x.com/search?q=${q}&f=live`, "X (Twitter) ‚Äî CVE + Ransomware"),
    linkRow(`https://www.bleepingcomputer.com/search/?q=${q}`, "BleepingComputer ‚Äî CVE + Ransomware"),
    linkRow(`https://www.google.com/search?q=${q}`, "Google ‚Äî CVE + Ransomware"),
    linkRow(`https://news.google.com/search?q=${q}`, "Google News ‚Äî CVE + Ransomware")
  ].join("<br>");
  const container = document.getElementById("searchLinks");
  container.insertAdjacentHTML('beforeend', `<div class="item"><div class="title">Ransomware-Focused Searches</div><div class="meta">${rows}</div></div>`);
}
/* ---------- Dashboard 2 Feeds ---------- */
const feeds = [
  { name:"0patch Blog", url:"https://blog.0patch.com/feeds/posts/default" },
  { name:"Anton on Security (Medium)", url:"https://medium.com/feed/anton-on-security" },
  { name:"Ars Technica ‚Äì Security", url:"https://arstechnica.com/tag/security/feed/" },
  { name:"ASEC (AhnLab) Blog", url:"https://asec.ahnlab.com/en/feed/" },
  { name:"AWS Security Blog", url:"https://aws.amazon.com/blogs/security/feed/" },
  { name:"Bitdefender Labs", url:"https://www.bitdefender.com/nuxt/api/en-us/rss/labs/" },
  { name:"BleepingComputer", url:"https://www.bleepingcomputer.com/feed/" },
  { name:"Broadcom/Symantec Enterprise Blogs", url:"https://sed-cms.broadcom.com/rss/v1/blogs/rss.xml" },
  { name:"Center for Internet Security ‚Äì Advisories", url:"https://www.cisecurity.org/feed/advisories" },
  { name:"CERT/CC Vulnerability Notes", url:"https://www.cisa.gov/cybersecurity-advisories/cybersecurity-advisories.xml" },
  { name:"Check Point Research", url:"https://research.checkpoint.com/feed/" },
  { name:"CISA Cybersecurity Advisories (All)", url:"https://www.cisa.gov/sites/default/files/feeds/alerts.xml" },
  { name:"CISA ICS Advisories", url:"https://www.cisa.gov/sites/default/files/feeds/ics-advisories.xml" },
  { name:"CISA ICS Medical Advisories", url:"https://www.cisa.gov/sites/default/files/feeds/ics-medical-advisories.xml" },
  { name:"Cisco Security Blog", url:"https://blogs.cisco.com/security/feed" },
  { name:"Cisco Talos Intelligence", url:"https://blog.talosintelligence.com/rss/" },
  { name:"Cloudflare Blog", url:"https://blog.cloudflare.com/rss/" },
  { name:"CloudSec (Google Cloud) Threat Intelligence", url:"https://cloudblog.withgoogle.com/topics/threat-intelligence/rss/" },
  { name:"Cofense", url:"https://cofense.com/feed/" },
  { name:"CrowdStrike Blog", url:"https://www.crowdstrike.com/en-us/blog/feed" },
  { name:"Cyble", url:"https://cyble.com/feed/" },
  { name:"Cybereason Blog", url:"https://www.cybereason.com/blog/rss.xml" },
  { name:"Dark Reading", url:"https://www.darkreading.com/rss.xml" },
  { name:"Darktrace Blog", url:"https://www.darktrace.com/blog/rss.xml" },
  { name:"DFIR Report", url:"https://thedfirreport.com/feed/" },
  { name:"DuskRise", url:"https://www.duskrise.com/feed/" },
  { name:"EclecticIQ", url:"https://blog.eclecticiq.com/rss.xml" },
  { name:"Exploit Database", url:"https://www.exploit-db.com/rss.xml" },
  { name:"Forescout", url:"https://www.forescout.com/feed/" },
  { name:"Fox-IT Blog", url:"https://blog.fox-it.com/feed/" },
  { name:"GBHackers", url:"https://gbhackers.com/feed/" },
  { name:"Google Online Security Blog", url:"https://feeds.feedburner.com/GoogleOnlineSecurityBlog" },
  { name:"Google TAG (Threat Analysis Group)", url:"https://blog.google/threat-analysis-group/rss/" },
  { name:"Graham Cluley", url:"https://grahamcluley.com/feed/" },
  { name:"Group-IB Blog", url:"https://www.group-ib.com/feed/blogfeed/" },
  { name:"Hackmageddon", url:"https://www.hackmageddon.com/feed/" },
  { name:"HackRead", url:"https://hackread.com/feed/" },
  { name:"Help Net Security", url:"https://www.helpnetsecurity.com/feed/" },
  { name:"HP Threat Research (HP Wolf Security)", url:"https://threatresearch.ext.hp.com/feed/" },
  { name:"Infoblox ‚Äì Threat Intelligence", url:"https://www.infoblox.com/blog/category/threat-intelligence/feed/" },
  { name:"Infosecurity Magazine ‚Äì News", url:"https://www.infosecurity-magazine.com/rss/news/" },
  { name:"Intego Mac Security Blog", url:"https://www.intego.com/mac-security-blog/feed/" },
  { name:"Intezer", url:"https://intezer.com/feed/" },
  { name:"Juniper Threat Research", url:"https://blogs.juniper.net/threat-research/feed" },
  { name:"Krebs on Security", url:"https://krebsonsecurity.com/feed/" },
  { name:"Lab52", url:"https://lab52.io/blog/feed/" },
  { name:"LevelBlue ‚Äì SpiderLabs Blog", url:"https://levelblue.com/blogs/spiderlabs-blog/rss.xml" },
  { name:"Malware Traffic Analysis (canonical)", url:"https://www.malware-traffic-analysis.net/blog-entries.rss" },
  { name:"Malwarebytes Labs", url:"https://www.malwarebytes.com/blog/feed/index.xml" },
  { name:"McAfee ‚Äì Advanced Threat Research", url:"https://www.mcafee.com/blogs/tag/advanced-threat-research/feed/" },
  { name:"McAfee ‚Äì Labs", url:"https://www.mcafee.com/blogs/other-blogs/mcafee-labs/feed/" },
  { name:"McAfee ‚Äì All Blogs", url:"https://www.mcafee.com/blogs/feed" },
  { name:"Microsoft Security Blog", url:"https://www.microsoft.com/security/blog/feed/" },
  { name:"Morphisec", url:"https://www.morphisec.com/feed/?post_type=blog" },
  { name:"Moonlock", url:"https://moonlock.com/feed" },
  { name:"MSRC Security Update Guide", url:"https://api.msrc.microsoft.com/update-guide/rss" },
  { name:"nao_sec (Research Team)", url:"https://nao-sec.org/feed" },
  { name:"NIST ‚Äì Cybersecurity Insights", url:"https://www.nist.gov/blogs/cybersecurity-insights/rss.xml" },
  { name:"Palo Alto Networks ‚Äì Main Blog", url:"https://www.paloaltonetworks.com/blog/feed/" },
  { name:"Palo Alto Networks ‚Äì Unit 42", url:"https://www.paloaltonetworks.com/blog/unit42/feed/" },
  { name:"Permiso", url:"https://permiso.io/blog/rss.xml" },
  { name:"PhishLabs", url:"https://www.phishlabs.com/feed" },
  { name:"Project Zero", url:"https://projectzero.google/feed.xml" },
  { name:"Proofpoint", url:"https://www.proofpoint.com/us/rss.xml" },
  { name:"Qualys Blog", url:"https://blog.qualys.com/feed" },
  { name:"Quarkslab", url:"https://blog.quarkslab.com/feeds/all.rss.xml" },
  { name:"Quick Heal Blog", url:"https://www.quickheal.com/blogs/feed/" },
  { name:"Rapid7 Blog", url:"https://www.rapid7.com/rss.xml" },
  { name:"Recorded Future Blog", url:"https://www.recordedfuture.com/blog/rss" },
  { name:"Reddit r/cybersecurity", url:"https://www.reddit.com/r/cybersecurity/.rss" },
  { name:"Reddit r/netsec", url:"https://www.reddit.com/r/netsec/.rss" },
  { name:"Rewterz", url:"https://rewterz.com/feed" },
  { name:"Risky Business Podcast", url:"https://risky.biz/rss/podcast/" },
  { name:"SANS Internet Storm Center (ISC Diary)", url:"https://isc.sans.edu/rssfeed_full.xml" },
  { name:"Schneier on Security (Cybersecurity tag)", url:"https://www.schneier.com/tag/cybersecurity/feed/" },
  { name:"Securelist (Kaspersky)", url:"https://securelist.com/feed/" },
  { name:"Security Affairs", url:"https://securityaffairs.com/feed" },
  { name:"Security Joes", url:"https://www.securityjoes.com/blog-feed.xml" },
  { name:"SecurityWeek", url:"https://www.securityweek.com/feed/" },
  { name:"SensePost", url:"https://sensepost.com/rss.xml" },
  { name:"SentinelOne Labs", url:"https://www.sentinelone.com/labs/feed/" },
  { name:"Silent Push", url:"https://www.silentpush.com/feed/" },
  { name:"SOC Prime", url:"https://socprime.com/blog/feed/" },
  { name:"SOCRadar", url:"https://socradar.io/feed/" },
  { name:"The Guardian ‚Äì Data & Computer Security", url:"https://www.theguardian.com/technology/data-computer-security/rss" },
  { name:"The Hacker News", url:"https://feeds.feedburner.com/TheHackersNews" },
  { name:"The Register ‚Äì Security Headlines", url:"https://www.theregister.com/security/headlines.rss" },
  { name:"Therecord.media", url:"https://therecord.media/feed" },
  { name:"ThreatMon", url:"https://threatmon.io/feed/" },
  { name:"Trend Micro (Simply Security)", url:"http://feeds.trendmicro.com/TrendMicroSimplySecurity" },
  { name:"Tripwire", url:"https://www.tripwire.com/blogs.xml" },
  { name:"Troy Hunt Blog", url:"https://www.troyhunt.com/rss/" },
  { name:"Unit 42 (legacy v2 feed)", url:"https://unit42.paloaltonetworks.com/feed/?v=2" },
  { name:"UpGuard ‚Äì Breaches", url:"https://www.upguard.com/breaches/rss.xml" },
  { name:"UpGuard ‚Äì News", url:"https://www.upguard.com/news/rss.xml" },
  { name:"Virus Bulletin", url:"https://www.virusbulletin.com/rss" },
  { name:"VirusTotal Blog", url:"https://blog.virustotal.com/feeds/posts/default" },
  { name:"Volexity", url:"https://www.volexity.com/feed/" },
  { name:"Webroot Blog", url:"https://www.webroot.com/blog/feed/" },
  { name:"WeLiveSecurity (ESET)", url:"https://www.welivesecurity.com/feed/" },
  { name:"WeLiveSecurity (ESET ‚Äì English site feed)", url:"https://www.welivesecurity.com/en/rss/feed/" },
  { name:"WIRED ‚Äì Security", url:"https://www.wired.com/feed/category/security/latest/rss" },
  { name:"Wiz ‚Äì Cloud Threat Landscape", url:"https://www.wiz.io/api/feed/cloud-threat-landscape/rss.xml" },
  { name:"ZDNet ‚Äì News", url:"https://www.zdnet.com/news/rss.xml" },
  { name:"Zero Day Initiative ‚Äì Published", url:"https://www.zerodayinitiative.com/rss/published/" },
  { name:"Zscaler ‚Äì Security Research", url:"https://www.zscaler.com/blogs/feeds/security-research" }
];

async function fetchFeed(feedUrl) {
  try {
    const response = await fetch(`https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(feedUrl)}`);
    if (!response.ok) {
      console.warn(`rss2json ${feedUrl} HTTP ${response.status}`);
      return [];
    }
    const data = await response.json();
    return Array.isArray(data.items) ? data.items.slice(0, 5) : [];
  } catch (error) {
    console.error(`rss2json error: ${feedUrl}`, error);
    return [];
  }
}

async function displayFeeds() {
  const container = document.getElementById("feed-container");
  if (!container) return;
  container.innerHTML = "";

  for (const feed of feeds) {
    const articles = await fetchFeed(feed.url);
    if (!articles.length) continue;

    const feedDiv = document.createElement("div");
    feedDiv.className = "feed";
    const listHtml = articles.map(article => `<li>${linkRow(article.link, article.title)}</li>`).join("");
    feedDiv.innerHTML = `<h2>${feed.name}</h2><ul>${listHtml}</ul>`;
    container.appendChild(feedDiv);
  }
}
setInterval(displayFeeds, 10 * 60 * 1000);
// Main CVE search flow
/* ---------- CVE Watcher (IIFE, KEV badge) ---------- */
;(async () => {
  // Create the button before we branch to file origin (ensures 'btn' exists)
  const btn = document.createElement('button');
  btn.id = 'watcherBtn';
  btn.className = 'btn';
  btn.textContent = 'CVE Watcher';

  // If opened via file:// keep only the button injection and return
  if (IS_FILE_ORIGIN) {
    function ensureWatcherButton() {
      let hdr = document.querySelector('header.cve-header');
      if (!hdr) {
        btn.style.position = 'fixed';
        btn.style.top = '60px';
        btn.style.right = '12px';
        btn.style.zIndex = '1500';
        document.body.appendChild(btn);
      } else {
        hdr.appendChild(btn);
      }
    }
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', ensureWatcherButton);
    } else {
      ensureWatcherButton();
    }
    return;
  }

  const STORAGE_KEY = 'cveWatcher.list';
  const INTERVAL_KEY = 'cveWatcher.interval';
  const NOTIFIED_KEY = 'cveWatcher.notified';

  const PAGE_SCAN_CAP = 8;

  const KEV_SET_KEY = 'cveWatcher.kevSet';
  const KEV_MAP_KEY = 'cveWatcher.kevMap';
  const KEV_FETCH_KEY = 'cveWatcher.kevFetchedAt';
  const KEV_REFRESH_MINUTES = 60;

  const notified = new Set();
  function loadNotified() {
    try {
      const arr = JSON.parse(localStorage.getItem(NOTIFIED_KEY) || '[]');
      if (Array.isArray(arr)) arr.forEach(k => notified.add(k));
    } catch {}
  }
  function persistNotified() {
    try {
      localStorage.setItem(NOTIFIED_KEY, JSON.stringify(Array.from(notified)));
    } catch {}
  }
  loadNotified();

  let kevSet = null;
  let kevMap = null;

  // ‚úÖ Option B: Reuse the earlier-defined KEV loader (uses KEV_JSON_URLS and its own fallback)
  await loadKEV();

  function minutesSince(ts) {
    if (!ts) return Infinity;
    const then = new Date(ts).getTime();
    if (Number.isNaN(then)) return Infinity;
    return (Date.now() - then) / (60 * 1000);
  }
  function shouldRefreshKev() {
    const last = localStorage.getItem(KEV_FETCH_KEY);
    return minutesSince(last) >= KEV_REFRESH_MINUTES || !kevSet || kevSet.size === 0;
  }

  // Local KEV refresher: builds kevSet/kevMap used by the watcher for badges & info
  async function refreshKev() {
    try {
      const kevUrl = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json';
      const text = await fetchTextWithFallback(kevUrl);
      const data = JSON.parse(text);
      const list = Array.isArray(data?.vulnerabilities) ? data.vulnerabilities : [];

      const ids = [];
      const map = {};

      for (const v of list) {
        const cve = String(v.cveID || v.cve_id || '')
          .toUpperCase()
          .replace(/[\u2010-\u2015\u2212]/g, '-'); // normalize various dash chars to '-'
        if (!cve) continue;
        ids.push(cve);
        map[cve] = {
          vendor: String(v.vendorProject || '').trim(),
          product: String(v.product || '').trim(),
          dateAdded: (v.dateAdded || v.date_added || '').slice(0, 10)
        };
      }

      kevSet = new Set(ids);
      kevMap = map;

      localStorage.setItem(KEV_SET_KEY, JSON.stringify(ids));
      localStorage.setItem(KEV_MAP_KEY, JSON.stringify(map));
      localStorage.setItem(KEV_FETCH_KEY, new Date().toISOString());
    } catch (e) {
      if (!kevSet) kevSet = new Set();
      if (!kevMap) kevMap = {};
      console.warn('refreshKev failed:', e.message);
    }
  }

  function isKev(cve) { return kevSet && kevSet.has(String(cve).toUpperCase()); }
  function kevInfo(cve) { return kevMap && kevMap[String(cve).toUpperCase()] || null; }

  // Insert the watcher button in the header
  function ensureWatcherButton() {
    let hdr = document.querySelector('header.cve-header');
    if (!hdr) {
      btn.style.position = 'fixed';
      btn.style.top = '60px';
      btn.style.right = '12px';
      btn.style.zIndex = '1500';
      document.body.appendChild(btn);
    } else {
      hdr.appendChild(btn);
    }
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureWatcherButton);
  } else {
    ensureWatcherButton();
  }

  // Overlay + controls
  const overlay = document.createElement('div');
  overlay.id = 'watcher';
  Object.assign(overlay.style, {
    display: 'none',
    position: 'fixed',
    top: '0', left: '0',
    width: '100%', height: '100%',
    background: 'rgba(0,0,0,0.7)',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: '1300'
  });
  overlay.innerHTML = `
<div class="settings-content" role="dialog" aria-modal="true" aria-labelledby="watcherTitle">
      <h2 id="watcherTitle">CVE Watcher</h2>
      <label>CVEs to watch (comma or newline separated)<br><textarea id="watcherList" rows="6" placeholder="CVE-2024-12345\nCVE-2023-99999"></textarea></label>
      <label>Poll interval (minutes, default 30)<br><input id="watcherInterval" type="number" min="5" value="30"></label>
        <div style="display:flex;gap:12px;margin-top:20px;flex-wrap:wrap">
        <button id="watcherSave" class="btn">Save &amp; Start</button>
        <button id="watcherStop" class="btn">Stop</button>
        <button id="watcherCheck" class="btn">Check now</button>
        <button id="watcherReset" class="btn">Reset dedupe</button>
        <button id="watcherKev" class="btn">Refresh KEV</button>
        <button id="watcherClose" class="btn">Close</button>
            <label>Sound Notifications: <input id="watcherSoundToggle" type="checkbox"></label>
      </div>
      <p class="meta">Stored locally in your browser (localStorage). Notifications appear on the main view.<br>Dedupe keys persist across sessions‚Äîuse ‚ÄúReset dedupe‚Äù to re-show hits.<br>KEV badge is informational.</p>
    </div>`;
  document.body.appendChild(overlay);

  // Notification bubble
  const notif = document.createElement('div');
  notif.id = 'watcherNotify';
  document.body.appendChild(notif);

  function kevBadge(kev) {
    if (!kev) return '';
    return `<span style="display:inline-block;margin-left:8px;padding:2px 6px;border-radius:999px;background:#c62828;color:#fff;font-size:11px;line-height:1;font-weight:600">KEV</span>`;
  }


// --- Sound toggles & rate limit ---
let __watcherSoundLastTs = 0;
// default to enabled unless user turned it off
if (localStorage.getItem('watcherSoundEnabled') === null) {
  localStorage.setItem('watcherSoundEnabled', 'true');
}

function queueWatcherSound(count) {
  if (!count) return;

  // respect user toggle
  if (localStorage.getItem('watcherSoundEnabled') === 'false') return;

  // rate-limit: avoid multiple beeps if many items arrive at once
  const now = Date.now();
  if (now - __watcherSoundLastTs < 5000) return; // 5 seconds min gap
  __watcherSoundLastTs = now;

  const audio = document.getElementById('watcherSound');
  if (!audio) return;

  // ensure volume sane
  audio.volume = 0.7;
  audio.currentTime = 0;
  audio.play().catch(() => {
    // Browser blocked autoplay. Ask for a one-time user gesture to unlock.
    const unlock = () => {
      audio.currentTime = 0;
      audio.play().catch(() => {/* ignore */});
    };
    document.addEventListener('click', unlock, { once: true });
    document.addEventListener('keydown', unlock, { once: true });
  });
}

function showNotification(items) {
  const dark = document.body.classList.contains('dark');
  let html = items.map(i => {
    const kinfo = i.kev ? kevInfo(i.cve) : null;
    const vendorProductCve = kinfo
      ? [kinfo.vendor, kinfo.product, i.cve].filter(Boolean).join(' ¬∑ ')
      : i.cve;
    const metaLine = `${vendorProductCve}${i.source ? ' ¬∑ ' + i.source : ''}`;
    return `<div style="background:${dark?'#1e1e1e':'#fff'};color:inherit;border:1px solid ${dark?'var(--border-dark)':'var(--border-light)'};border-radius:8px;padding:12px;margin-top:8px;box-shadow:0 4px 12px rgba(0,0,0,0.2)"><div style="font-weight:600">CVE Watcher hit: ${i.cve}${kevBadge(i.kev)}</div><div style="font-size:13px;margin:6px 0">${linkRow(i.link, 'Source')} ¬∑ ${metaLine}</div></div>`;
  }).join('');
  
  // Optional: Add a close button at the bottom (comment out if you don't want it)
  html += `<div style="text-align: center; margin-top: 16px;"><button class="btn" onclick="document.getElementById('watcherNotify').style.display='none'">Close</button></div>`;
  
  notif.innerHTML = html;
  notif.style.display = 'block';
  // üîä play a single beep for this batch of items
  queueWatcherSound(items.length);
  // Auto-hide after 15 seconds (adjust timeout as needed)
  setTimeout(() => { notif.style.display = 'none'; }, 15000);
}

  function parseList(raw) {
    return (raw || '')
      .toUpperCase()
      .split(/[\s,;]+/)
      .map(s => s.trim())
      .filter(s => /^CVE-\d{4}-\d{4,}$/.test(s));
  }

  function getSources() {
    return [
  { name:"0patch Blog", url:"https://blog.0patch.com/feeds/posts/default" },
  { name:"Anton on Security (Medium)", url:"https://medium.com/feed/anton-on-security" },
  { name:"Ars Technica ‚Äì Security", url:"https://arstechnica.com/tag/security/feed/" },
  { name:"ASEC (AhnLab) Blog", url:"https://asec.ahnlab.com/en/feed/" },
  { name:"AWS Security Blog", url:"https://aws.amazon.com/blogs/security/feed/" },
  { name:"Bitdefender Labs", url:"https://www.bitdefender.com/nuxt/api/en-us/rss/labs/" },
  { name:"BleepingComputer", url:"https://www.bleepingcomputer.com/feed/" },
  { name:"Broadcom/Symantec Enterprise Blogs", url:"https://sed-cms.broadcom.com/rss/v1/blogs/rss.xml" },
  { name:"Center for Internet Security ‚Äì Advisories", url:"https://www.cisecurity.org/feed/advisories" },
  { name:"CERT/CC Vulnerability Notes", url:"https://www.cisa.gov/cybersecurity-advisories/cybersecurity-advisories.xml" },
  { name:"Check Point Research", url:"https://research.checkpoint.com/feed/" },
  { name:"CISA Cybersecurity Advisories (All)", url:"https://www.cisa.gov/sites/default/files/feeds/alerts.xml" },
  { name:"CISA ICS Advisories", url:"https://www.cisa.gov/sites/default/files/feeds/ics-advisories.xml" },
  { name:"CISA ICS Medical Advisories", url:"https://www.cisa.gov/sites/default/files/feeds/ics-medical-advisories.xml" },
  { name:"Cisco Security Blog", url:"https://blogs.cisco.com/security/feed" },
  { name:"Cisco Talos Intelligence", url:"https://blog.talosintelligence.com/rss/" },
  { name:"Cloudflare Blog", url:"https://blog.cloudflare.com/rss/" },
  { name:"CloudSec (Google Cloud) Threat Intelligence", url:"https://cloudblog.withgoogle.com/topics/threat-intelligence/rss/" },
  { name:"Cofense", url:"https://cofense.com/feed/" },
  { name:"CrowdStrike Blog", url:"https://www.crowdstrike.com/en-us/blog/feed" },
  { name:"Cyble", url:"https://cyble.com/feed/" },
  { name:"Cybereason Blog", url:"https://www.cybereason.com/blog/rss.xml" },
  { name:"Dark Reading", url:"https://www.darkreading.com/rss.xml" },
  { name:"Darktrace Blog", url:"https://www.darktrace.com/blog/rss.xml" },
  { name:"DFIR Report", url:"https://thedfirreport.com/feed/" },
  { name:"DuskRise", url:"https://www.duskrise.com/feed/" },
  { name:"EclecticIQ", url:"https://blog.eclecticiq.com/rss.xml" },
  { name:"Exploit Database", url:"https://www.exploit-db.com/rss.xml" },
  { name:"Forescout", url:"https://www.forescout.com/feed/" },
  { name:"Fox-IT Blog", url:"https://blog.fox-it.com/feed/" },
  { name:"GBHackers", url:"https://gbhackers.com/feed/" },
  { name:"Google Online Security Blog", url:"https://feeds.feedburner.com/GoogleOnlineSecurityBlog" },
  { name:"Google TAG (Threat Analysis Group)", url:"https://blog.google/threat-analysis-group/rss/" },
  { name:"Graham Cluley", url:"https://grahamcluley.com/feed/" },
  { name:"Group-IB Blog", url:"https://www.group-ib.com/feed/blogfeed/" },
  { name:"Hackmageddon", url:"https://www.hackmageddon.com/feed/" },
  { name:"HackRead", url:"https://hackread.com/feed/" },
  { name:"Help Net Security", url:"https://www.helpnetsecurity.com/feed/" },
  { name:"HP Threat Research (HP Wolf Security)", url:"https://threatresearch.ext.hp.com/feed/" },
  { name:"Infoblox ‚Äì Threat Intelligence", url:"https://www.infoblox.com/blog/category/threat-intelligence/feed/" },
  { name:"Infosecurity Magazine ‚Äì News", url:"https://www.infosecurity-magazine.com/rss/news/" },
  { name:"Intego Mac Security Blog", url:"https://www.intego.com/mac-security-blog/feed/" },
  { name:"Intezer", url:"https://intezer.com/feed/" },
  { name:"Juniper Threat Research", url:"https://blogs.juniper.net/threat-research/feed" },
  { name:"Krebs on Security", url:"https://krebsonsecurity.com/feed/" },
  { name:"Lab52", url:"https://lab52.io/blog/feed/" },
  { name:"LevelBlue ‚Äì SpiderLabs Blog", url:"https://levelblue.com/blogs/spiderlabs-blog/rss.xml" },
  { name:"Malware Traffic Analysis (canonical)", url:"https://www.malware-traffic-analysis.net/blog-entries.rss" },
  { name:"Malwarebytes Labs", url:"https://www.malwarebytes.com/blog/feed/index.xml" },
  { name:"McAfee ‚Äì Advanced Threat Research", url:"https://www.mcafee.com/blogs/tag/advanced-threat-research/feed/" },
  { name:"McAfee ‚Äì Labs", url:"https://www.mcafee.com/blogs/other-blogs/mcafee-labs/feed/" },
  { name:"McAfee ‚Äì All Blogs", url:"https://www.mcafee.com/blogs/feed" },
  { name:"Microsoft Security Blog", url:"https://www.microsoft.com/security/blog/feed/" },
  { name:"Morphisec", url:"https://www.morphisec.com/feed/?post_type=blog" },
  { name:"Moonlock", url:"https://moonlock.com/feed" },
  { name:"MSRC Security Update Guide", url:"https://api.msrc.microsoft.com/update-guide/rss" },
  { name:"nao_sec (Research Team)", url:"https://nao-sec.org/feed" },
  { name:"NIST ‚Äì Cybersecurity Insights", url:"https://www.nist.gov/blogs/cybersecurity-insights/rss.xml" },
  { name:"Palo Alto Networks ‚Äì Main Blog", url:"https://www.paloaltonetworks.com/blog/feed/" },
  { name:"Palo Alto Networks ‚Äì Unit 42", url:"https://www.paloaltonetworks.com/blog/unit42/feed/" },
  { name:"Permiso", url:"https://permiso.io/blog/rss.xml" },
  { name:"PhishLabs", url:"https://www.phishlabs.com/feed" },
  { name:"Project Zero", url:"https://projectzero.google/feed.xml" },
  { name:"Proofpoint", url:"https://www.proofpoint.com/us/rss.xml" },
  { name:"Qualys Blog", url:"https://blog.qualys.com/feed" },
  { name:"Quarkslab", url:"https://blog.quarkslab.com/feeds/all.rss.xml" },
  { name:"Quick Heal Blog", url:"https://www.quickheal.com/blogs/feed/" },
  { name:"Rapid7 Blog", url:"https://www.rapid7.com/rss.xml" },
  { name:"Recorded Future Blog", url:"https://www.recordedfuture.com/blog/rss" },
  { name:"Reddit r/cybersecurity", url:"https://www.reddit.com/r/cybersecurity/.rss" },
  { name:"Reddit r/netsec", url:"https://www.reddit.com/r/netsec/.rss" },
  { name:"Rewterz", url:"https://rewterz.com/feed" },
  { name:"Risky Business Podcast", url:"https://risky.biz/rss/podcast/" },
  { name:"SANS Internet Storm Center (ISC Diary)", url:"https://isc.sans.edu/rssfeed_full.xml" },
  { name:"Schneier on Security (Cybersecurity tag)", url:"https://www.schneier.com/tag/cybersecurity/feed/" },
  { name:"Securelist (Kaspersky)", url:"https://securelist.com/feed/" },
  { name:"Security Affairs", url:"https://securityaffairs.com/feed" },
  { name:"Security Joes", url:"https://www.securityjoes.com/blog-feed.xml" },
  { name:"SecurityWeek", url:"https://www.securityweek.com/feed/" },
  { name:"SensePost", url:"https://sensepost.com/rss.xml" },
  { name:"SentinelOne Labs", url:"https://www.sentinelone.com/labs/feed/" },
  { name:"Silent Push", url:"https://www.silentpush.com/feed/" },
  { name:"SOC Prime", url:"https://socprime.com/blog/feed/" },
  { name:"SOCRadar", url:"https://socradar.io/feed/" },
  { name:"The Guardian ‚Äì Data & Computer Security", url:"https://www.theguardian.com/technology/data-computer-security/rss" },
  { name:"The Hacker News", url:"https://feeds.feedburner.com/TheHackersNews" },
  { name:"The Register ‚Äì Security Headlines", url:"https://www.theregister.com/security/headlines.rss" },
  { name:"Therecord.media", url:"https://therecord.media/feed" },
  { name:"ThreatMon", url:"https://threatmon.io/feed/" },
  { name:"Trend Micro (Simply Security)", url:"http://feeds.trendmicro.com/TrendMicroSimplySecurity" },
  { name:"Tripwire", url:"https://www.tripwire.com/blogs.xml" },
  { name:"Troy Hunt Blog", url:"https://www.troyhunt.com/rss/" },
  { name:"Unit 42 (legacy v2 feed)", url:"https://unit42.paloaltonetworks.com/feed/?v=2" },
  { name:"UpGuard ‚Äì Breaches", url:"https://www.upguard.com/breaches/rss.xml" },
  { name:"UpGuard ‚Äì News", url:"https://www.upguard.com/news/rss.xml" },
  { name:"Virus Bulletin", url:"https://www.virusbulletin.com/rss" },
  { name:"VirusTotal Blog", url:"https://blog.virustotal.com/feeds/posts/default" },
  { name:"Volexity", url:"https://www.volexity.com/feed/" },
  { name:"Webroot Blog", url:"https://www.webroot.com/blog/feed/" },
  { name:"WeLiveSecurity (ESET)", url:"https://www.welivesecurity.com/feed/" },
  { name:"WeLiveSecurity (ESET ‚Äì English site feed)", url:"https://www.welivesecurity.com/en/rss/feed/" },
  { name:"WIRED ‚Äì Security", url:"https://www.wired.com/feed/category/security/latest/rss" },
  { name:"Wiz ‚Äì Cloud Threat Landscape", url:"https://www.wiz.io/api/feed/cloud-threat-landscape/rss.xml" },
  { name:"ZDNet ‚Äì News", url:"https://www.zdnet.com/news/rss.xml" },
  { name:"Zero Day Initiative ‚Äì Published", url:"https://www.zerodayinitiative.com/rss/published/" },
  { name:"Zscaler ‚Äì Security Research", url:"https://www.zscaler.com/blogs/feeds/security-research" },
  { name: "X (Twitter) ‚Äî Live Search", url: "https://x.com/search?q={{CVE}}&src=recent_search_click&f=live", type: "x" }
    ];
  }

  // CyCognito emerging threats (best-effort)
  async function fetchCyCognitoThreats() {
    const url = 'https://www.cycognito.com/emerging-threats/';
    try {
      const html = await fetchTextWithFallback(url);
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');

      const threatSections = doc.querySelectorAll('h2, h3, h4');
      const threats = [];

      threatSections.forEach(h => {
        const text = h.textContent.trim();
        const cveMatch = text.match(/CVE-\d{4}-\d{4,}/i);
        if (!cveMatch) return;

        const cve = cveMatch[0].toUpperCase();

        let published = 'Unknown';
        let next = h.nextElementSibling;
        while (next) {
          const dateMatch = next.textContent.match(/Published:\s*(\d{2}\/\d{2}\/\d{4})/i);
          if (dateMatch) {
            published = dateMatch[1];
            break;
          }
          next = next.nextElementSibling;
        }

        threats.push({
          cve,
          published,
          title: text,
          link: url + '#' + cve.toLowerCase().replace(/-/g, '')
        });
      });

      return threats;
    } catch (e) {
      console.warn('CyCognito fetch failed:', e);
      return [];
    }
  }

  const CYC_STATE_KEY = 'cveWatcher.cyCognitoState';
  function norm(text) { return (text || '').replace(/[\u2010\u2011\u2012\u2013\u2014\u2212]/g, '-').toUpperCase(); }
  function buildCveRegex(cve) {
    const m = String(cve).match(/^CVE-(\d{4})-(\d{4,})$/i);
    if (!m) return null;
    const year = m[1], id = m[2];
    return new RegExp(`CVE[\\s\\-]+${year}[\\s\\-]+${id}`, 'i');
  }

  async function pageMentionsCve(url, cveUpper) {
    try {
      const html = await fetchTextWithFallback(url);
      const text = norm(new DOMParser().parseFromString(html, 'text/html').documentElement.textContent);
      const regex = buildCveRegex(cveUpper);
      return regex ? regex.test(text) : text.includes(norm(cveUpper));
    } catch {
      return false;
    }
  }

  async function fetchMentionsForCve(cve) {
    const sources = getSources();
    const hits = [];

    await Promise.all(sources.map(async s => {
      if (s.type === 'x') {
        const xLink = s.url.replace('{{CVE}}', encodeURIComponent(cve));
        const key = `XSEARCH|${cve}`;
        if (!notified.has(key)) {
          notified.add(key);
          hits.push({ cve, title: `X Live Search for ${cve}`, link: xLink, source: s.name, kev: isKev(cve) });
        }
        return;
      }

      try {
        const xml = await fetchTextWithFallback(s.url);
        const doc = new DOMParser().parseFromString(xml, 'application/xml');
        const items = Array.from(doc.querySelectorAll('item, entry')).slice(0, 60);
        const cveUpper = cve.toUpperCase();

        let pageScanBudget = PAGE_SCAN_CAP;

        const itemMentionsCve = (item, cveUpper) => {
          const pick = sel => item.querySelector(sel)?.textContent || '';
          const title = pick('title');
          const desc = pick('description') || pick('summary');
          const contentNSq = item.querySelector('content\\:encoded')?.textContent || '';
          const contentNSt = item.getElementsByTagName('content:encoded')?.[0]?.textContent || '';
          const contentNS = contentNSq || contentNSt;
          const content = contentNS || pick('content');
          const blob = norm(`${title} ${desc} ${content}`);
          const regex = buildCveRegex(cveUpper);
          const matched = regex ? regex.test(blob) : blob.includes(norm(cveUpper));
          return { matched, hasContentEncoded: !!contentNS };
        };

        for (const it of items) {
          const title = it.querySelector('title')?.textContent || '';
          const linkNode = it.querySelector('link[href]');
          const rawLink = it.querySelector('link')?.textContent || linkNode?.getAttribute('href') || '#';
          const link = (rawLink || '#').trim();

          const { matched, hasContentEncoded } = itemMentionsCve(it, cveUpper);
          let finalMatch = matched;

          if (!finalMatch && link && link !== '#' && pageScanBudget > 0 && !hasContentEncoded) {
            finalMatch = await pageMentionsCve(link, cveUpper);
            pageScanBudget--;
          }

          if (finalMatch) {
            const key = `${cve}|${link}`;
            if (!notified.has(key)) {
              notified.add(key);
              hits.push({ cve, title: title || link, link, source: s.name, kev: isKev(cve) });
            }
          }
        }
      } catch {}
    }));

    return hits;
  }

  async function checkCyCognito() {
    const threats = await fetchCyCognitoThreats();
    if (!threats.length) return [];

    let state = JSON.parse(localStorage.getItem(CYC_STATE_KEY) || '{}');
    const lastThreats = state.lastThreats || [];
    const lastCVEs = new Set(lastThreats.map(t => t.cve));

    const newHits = threats.filter(t => !lastCVEs.has(t.cve));

    state.lastThreats = threats.map(t => ({ cve: t.cve, published: t.published }));
    state.lastCheck = Date.now();
    localStorage.setItem(CYC_STATE_KEY, JSON.stringify(state));

    return newHits.map(hit => ({
      cve: hit.cve,
      title: `CyCognito Emerging Threat: ${hit.title}`,
      link: hit.link || 'https://www.cycognito.com/emerging-threats/',
      source: 'CyCognito Emerging Threats',
      kev: isKev(hit.cve)
    }));
  }

  // Initial KEV refresh (local set/map) if needed
  if (shouldRefreshKev()) {
    await refreshKev();
  }

  let timer = null;

  async function poll() {
    if (shouldRefreshKev()) {
      await refreshKev();
    }

    const list = parseList(localStorage.getItem(STORAGE_KEY));
    const allHits = [];

    for (const cve of list) {
      const hits = await fetchMentionsForCve(cve);
      allHits.push(...hits);
    }

    const cyHits = await checkCyCognito();
    allHits.push(...cyHits);

    if (allHits.length) {
      persistNotified();

      const wc = document.getElementById('watchContent');
      if (wc) {
        const html = allHits.map(r => {
          const titleText = `${r.cve ? r.cve + ': ' : ''}${r.title || r.link}`;
          const kinfo = r.kev ? kevInfo(r.cve) : null;
          const vendorProdCve = kinfo
            ? [kinfo.vendor, kinfo.product, r.cve].filter(Boolean).join(' ¬∑ ')
            : (r.cve || 'CyCognito Update');
          const metaLine = `${vendorProdCve}${r.source ? ' ¬∑ ' + r.source : ''} ¬∑ ${new Date().toLocaleString()}`;
          return `<div class="item"><div class="title">${linkRow(r.link, titleText)}${kevBadge(r.kev)}</div><div class="meta">${metaLine}</div></div>`;
        }).join('');

        wc.insertAdjacentHTML('afterbegin', html);
      }

      showNotification(allHits.slice(0, 3));
    }
  }

  function start() {
    const minutes = Math.max(5, Number(localStorage.getItem(INTERVAL_KEY) || 30));
    if (timer) clearInterval(timer);
    timer = setInterval(poll, minutes * 60 * 1000);
    poll();
  }

  function stop() {
    if (timer) { clearInterval(timer); timer = null; }
  }

  // UI wiring
  btn.addEventListener('click', () => {
    document.getElementById('watcherList').value = (localStorage.getItem(STORAGE_KEY) || '');
    document.getElementById('watcherInterval').value = (localStorage.getItem(INTERVAL_KEY) || 30);
    overlay.style.display = 'flex';
  });

  overlay.addEventListener('click', (e) => { if (e.target.id === 'watcher') overlay.style.display = 'none'; });
  overlay.querySelector('#watcherClose').addEventListener('click', () => overlay.style.display = 'none');

  overlay.querySelector('#watcherSave').addEventListener('click', () => {
    const list = parseList(document.getElementById('watcherList').value);
    localStorage.setItem(STORAGE_KEY, list.join('\n'));

    const interval = Math.max(5, Number(document.getElementById('watcherInterval').value) || 30);
    localStorage.setItem(INTERVAL_KEY, String(interval));

    overlay.style.display = 'none';
    if (typeof toast === 'function') toast(`CVE Watcher saved (${list.length} CVE${list.length !== 1 ? 's' : ''}; ${interval} min)`);
    start();
  });

  overlay.querySelector('#watcherStop').addEventListener('click', () => {
    stop();
    overlay.style.display = 'none';
    if (typeof toast === 'function') toast('CVE Watcher stopped');
  });

  overlay.querySelector('#watcherCheck').addEventListener('click', async () => {
    if (typeof toast === 'function') toast('Checking now‚Ä¶');
    await poll();
    if (typeof toast === 'function') toast('Check complete');
  });

  overlay.querySelector('#watcherReset').addEventListener('click', () => {
    notified.clear();
    localStorage.removeItem(NOTIFIED_KEY);
    if (typeof toast === 'function') toast('CVE Watcher dedupe reset ‚Äî hits will re-show on next check');
  });

  overlay.querySelector('#watcherKev').addEventListener('click', async () => {
    if (typeof toast === 'function') toast('Refreshing KEV‚Ä¶');
    await refreshKev();
    if (typeof toast === 'function') toast(`KEV refreshed (${kevSet.size} entries)`);
  });

  // Start automatically if there‚Äôs a saved list
  if (parseList(localStorage.getItem(STORAGE_KEY)).length) {
    start();
  }
})();
/* ---------- Tabs ---------- */
function switchTab(tabIndex) {
  const tabs = [document.getElementById('tab1'), document.getElementById('tab2')];
  document.querySelectorAll('nav button').forEach((btn, i) => { btn.classList.toggle('active', i === tabIndex); });
  tabs.forEach((tab, i) => { tab.classList.toggle('active', i === tabIndex); });
}
/* ---------- Search bindings ---------- */
function handleSearch() {
  const inputEl = document.getElementById('cve');
  const v = (inputEl?.value || '').trim();
  if (!v) {
    toast('Please enter a CVE or vendor/product');
    return;
  }
  const input = v.toUpperCase();
  if (isCVE(input)) {
    runSearch();
  } else {
    runVendorProductSearch(v);  // pass original case for keyword search
  }
}
  function bindSearchHandlers() {
  try {
    const btn = document.getElementById('go'); const input = document.getElementById('cve');
    if (btn) { btn.onclick = null; btn.addEventListener('click', handleSearch); }
    if (input) { input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); handleSearch(); } }); }
  } catch (e) { console.error('bindSearchHandlers error:', e); }
}

/* ---------- Clear ---------- */
// --- Clear CVE-only fields (leave Watcher & feeds alone) ---
function clearCveFields() {
  try {
    // Input
    const inputEl = document.getElementById('cve');
    if (inputEl) inputEl.value = '';

    // CVE Details panel
    const cveContent = document.getElementById('cveContent');
    if (cveContent) {
      cveContent.innerHTML = '<div class="meta">Enter a CVE or Vendor/Product and click Run.</div>';
    }

    // Notable Sources & References
    const sourcesContent = document.getElementById('sourcesContent');
    if (sourcesContent) {
      sourcesContent.innerHTML = '<div class="meta">Will appear after running a CVE.</div>';
    }

    // Relevant Searches
    const searchLinks = document.getElementById('searchLinks');
    if (searchLinks) {
      searchLinks.innerHTML = '<div class="meta">Enter a term above and click Run to populate links.</div>';
    }

    // Hide any loading overlay if visible
    const loadingEl = document.getElementById('loading');
    if (loadingEl) loadingEl.style.display = 'none';

    // Reset AI analysis context and close modal if open
    if (typeof __lastAnalysisContext !== 'undefined') {
      __lastAnalysisContext = null;
    }
    if (typeof closeAnalysisModal === 'function') {
      closeAnalysisModal();
    }
    const analysisBody = document.getElementById('analysisBody');
    const analysisStatus = document.getElementById('analysisStatus');
    if (analysisBody) analysisBody.textContent = '';
    if (analysisStatus) analysisStatus.textContent = 'Preparing analysis‚Ä¶';

    // IMPORTANT: Do NOT touch Exploitation Watch (#watchContent),
    // VulnCheck panel (#vulncheckContent), or any cveWatcher.* localStorage keys.
    // This preserves the Watcher state and recent feed results.

    toast('CVE fields cleared');
  } catch (e) {
    console.error('clearCveFields error:', e);
    toast('Clear failed ‚Äî check console for details.');
  }
}

// One DOMContentLoaded listener with everything
document.addEventListener("DOMContentLoaded", () => {
  initTheme();
  loadVulnCheck();
  loadExploitationWatch();
  displayFeeds();
  initInlineAnalysis();
  
  // Search handlers
  document.getElementById("go")?.addEventListener("click", handleSearch);
  document.getElementById("cve")?.addEventListener("keydown", e => {
    if (e.key === "Enter") {
      e.preventDefault();
      handleSearch();
    }
  });

  document.getElementById("closeModal")?.addEventListener("click", () => {
    document.getElementById("attackModal").style.display = "none";
  });

  // Clear button
  document.getElementById('clearCve')?.addEventListener('click', clearCveFields);

  // CVE link click ‚Üí load single CVE view
  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('cve-link')) {
      e.preventDefault();
      const cveId = e.target.getAttribute('data-cve');
      if (!cveId || !isCVE(cveId)) return;

      previousVendorSearch = { ...vendorSearchState };

      const inputEl = document.getElementById('cve');
      if (inputEl) inputEl.value = cveId;

      const loadingEl = document.getElementById('loading');
      if (loadingEl) loadingEl.style.display = 'flex';

      // Hide back button during new load (prevents stale buttons)
      const backBtn = document.getElementById('backToList');
      if (backBtn) backBtn.style.display = 'none';

      runSearch()  // ‚Üê no await needed unless you make runSearch return Promise
        .then(() => {
          let backBtn = document.getElementById('backToList');
          if (!backBtn) {
            const header = document.querySelector('header.cve-header');
            if (!header) return;
            backBtn = document.createElement('button');
            backBtn.id = 'backToList';
            backBtn.className = 'btn';
            backBtn.textContent = '‚Üê Back to List';
            backBtn.style.marginLeft = '12px';
            header.appendChild(backBtn);
          }
          backBtn.style.display = 'inline-block';
        })
        .catch(err => {
          console.error(err);
          toast('Failed to load CVE details');
        })
        .finally(() => {
          if (loadingEl) loadingEl.style.display = 'none';
        });
    }
  });

  // Back button click ‚Üí restore list
  document.addEventListener('click', function(e) {
    if (e.target.id === 'backToList' && previousVendorSearch) {
      e.preventDefault();

      vendorSearchState = { ...previousVendorSearch };

      const inputEl = document.getElementById('cve');
      if (inputEl) inputEl.value = previousVendorSearch.keyword || '';

      renderVendorProductResults(
        {
          vulnerabilities: previousVendorSearch.allVulns,
          totalResults: previousVendorSearch.totalResults,
          // You can omit startIndex if render function doesn't strictly need it
          // startIndex: previousVendorSearch.currentStartIndex - previousVendorSearch.allVulns.length
        },
        previousVendorSearch.keyword,
        false
      );

      const backBtn = document.getElementById('backToList');
      if (backBtn) backBtn.style.display = 'none';

      document.getElementById('cveContent')?.scrollIntoView({ behavior: 'smooth' });
    }
  });
  });
  // ---- END GUARD (temporary) ----
(function __end_guard__() { return true; })();
</script>
</html>
